[{"content":"hi，大家应该发现了，我的博客大变样了（不是💩样）\n因为我把博客从Hexo迁移到了Hugo\n2022年疫情上网课的时候，我用Hexo搭建了我的个人博客\n2024将博客迁移至了Hugo\n😯原因 优点 相比Hexo，Hugo的静态生成速度更快。在本地运行后半秒不到就能在本地生成完页面，方便调试。 看了L1nSn0w大佬的博客后，被Stack主题这个简约舒适的博客页面狠狠种草了。个人觉得这样的页面阅读体验非常好，没有其他花里胡哨的东西吸引眼球，进来就是一排文章，方便阅读。 最主要是为了减少折腾，这让我可以专心地写文章。不再反复折腾博客页面。 缺点 Hugo在国内的社区没有Hexo的大，意味着遇到问题比较难找到解决方法，需要一定Debug能力。 没有Hexo那么多插件功能 So 对我来说，Hugo会更加适合我。\n大家可以根据个人需求和喜好选择，看看自己是要简约的，还是多功能、自定义化高的。\n这里奉上我的Hexo博客搭建教程\n😎关于Hugo安装 这里列出我在hugo博客搭建过程中阅读的文章：\n【L1nSn0w】(1)带着Stack主题入坑Hugo\n【L1nSn0w】(2)部署你的Hugo博客\n【CSDN】GitHub Action自动化部署Hugo博客\n【L1nSn0w】(3)Stack主题的自定义\n我在自动部署处做了些改动：\n把deploy_key那行换成PERSONAL_TOKEN: ${{ secrets.PERSONAL_TOKEN }}，然后在仓库设置添加secret变量PERSONAL_TOKEN，里面填token。token在用户设置中创建，要勾选repo和workflow权限。\n","date":"2024-05-17T00:00:00Z","image":"https://p.fiveth.cc/img/2024/0518131750.webp","permalink":"https://blog.fiveth.cc/p/hello-hugo/","title":"Hello Hugo"},{"content":"今天偶然在微信公众号看到天猫618的规则改了，取消了预售制度。\n虽然以前的规则我也不太了解，不过想到正好有东西要买，所以就提前做了波攻略，看看怎么样买最省钱。\n接下来让我们看看吧~\n🛍️今年618规则 活动时间 取消5月10号的预售制度，购物爆发节点改为5.20和5.31。\n年中开门红：5.20 8:00后 618年中狂欢节：5.31 8:00后 注意：年中开门红价格\u0026lt;618年中狂欢节价格\n最好在活动开始后马上买，不然优惠会偷偷变小。 所以尽量5.20买，有遗漏的就等5.31。\n满减机制： 满300减50 满200减30 技巧：凑不够可以买不需要的，下完单后退货🤪\n价保制度 价保时间延长至7月5日，只要买贵了，点一键价保，强制退还差价。\n✍️小技巧 优惠卷：记得在活动主页领品类卷，可以叠加优惠。 直播间：进品牌直播间的专属链接下单，会有优惠。 入会：第一次下单的品牌记得先入会，领新人优惠卷。 会员福利：88VIP享九五折，大额优惠券，无限次退货，品牌会员额外优惠。 最后，虽然活动促销很好，但是不要掉入资本主义的陷阱，要注意理性消费，不要因为有折扣就买不需要的物品。\n本文参考：\n【bilibili】618最全攻略！规则巨变！一篇讲清怎么买最划算！ 【黑马公社】淘宝下狠手，12年“毒瘤”，说砍就砍！ ","date":"2024-05-09T22:11:16Z","image":"https://p.fiveth.cc/img/2024/0518115531.jpg","permalink":"https://blog.fiveth.cc/p/208b/","title":"618购物攻略：今年规则大改，取消预售"},{"content":"{% note info flat %}\n本篇前文：如何用Hexo搭建个人博客? 本文基于Hexo博客搭建基础教程(二)修改，部分转载 我的Hexo优化系列：Hexo文章目录 {% endnote %} 我的博客搭建教程是一年前写的了，非常感谢fomalhaut，当时我是跟着他的教程一步步搭建的。最近我终于在b站发了视频版的博客搭建教程，有很多朋友想进一步优化博客。这篇文章接上一篇，教大家将博客部署到vercel、主题安装、Hexo博客的基础用法。\nVercel部署 Github提供的网址在国内的访问速度较慢，所以推荐在搭建完后用Vercel部署，再通过Vercel绑定到自己的域名上，这样会速度会很快。\n因为Vercel给我们分配的域名在国内是无法访问的，所以我们需要把在Vercel部署的绑定到自己的域名上，这样就可以访问了。\n域名可以在阿里云等域名供应商购买，我用的是西部数码，便宜好用。\n建议选用com，cn或cc等常用好记的顶域，对SEO比较友好，自定义部分的长度尽可能短，别人才会更容易地记住你的网站，域名就是网站的名片。\n使用Vercel部署 首先需要一个Vercel账号，这里推荐用GitHub账户关联，这样你就可以在vercel中直接托管你的GitHub库中的项目了，实现开发部署一步到位（网络不流畅可以考虑挂梯子）。 当你用你的Github账户关联并绑定手机号登录之后，点击右上角的Add New Project创建新的项目，之后导入选项那里选择Continue with Github，这时候应该能看到你Github账号的仓库，选择你刚刚部署成功的存储静态博客的仓库\u0026lt;username\u0026gt;.github.io右边的Import选项，表示你要导入该仓库。 起一个只能有字母、数字或者或者连字符的项目名称，然后其他默认，点击Deploy，等待一分钟即可部署成功，部署成功后电极Continue to Dashboard跳转到控制面板，下图所示就是控制面板，看到就代表成功部署到了，但是我们现在还不能访问他给出的域，因为GFW把Vercel屏蔽了。 绑定自定义域名 现在你有一个github托管的网址username.github.io，以及在Vercel上有一个blog-demo-chi.vercel.app，但是它国内无法访问，所以这时候我们就需要将Vercel部署的网页绑定到自己的域名上。\n接下来我们绑定自己的域名：\n点击Vercel控制面板右上角的View Domains查看当前的域，我们可以看到仅有Vercel给你预分配的一个域名，此时我们输入我们要用的域名，添加后他会提示你添加一条DNS解析记录。 我买的域名是fiveth.cc，我决定用二级域名blog.fiveth.cc当我博客的域名，大家也可以直接用根域名\n接下来在域名解析记录里面添加记录，其中记录类型对应Type，主机记录对应Name，记录值对应Value，其他的设置默认即可。 如果不成功，可以尝试统一用A记录，值76.223.126.88\n如下是我的示例，blog解析出来的域名是blog.fiveth.cc，@解析出来的是根域名fiveth.cc\n回到Vercel刚刚查看域名的地方，如果操作没问题，应该会显示域名配置成功的提示，此时就可以通过自定义域名来访问我们搭建的网站了。 当你有了新的域名之后，需要将[BlogRoot]\\_config.yml文件中的url配置项改为自己的新域名，这样博客的文章链接才会正确生成。 安装主题 Butterfly主题 Butterfly主题是最流行的主题，拥有很大的社区，自定义度高，还可以用来魔改。\n这是官方的安装文档：【Butterfly 安裝文檔】\nButterfly的魔改：推荐文章【博客魔改教程总结(一)】\n安知鱼主题 安知鱼主题一款基于Butterfly主题修改的主题，也是我目前在使用的。\n如果大家也想用和我一样的话，可以直接跟着【安知鱼主题官方文档】进行安装和配置，文档非常详细。\n其他主题 hexo还有很多其他主题，可以在hexo主题中找到。\n基础用法 Front-matter Front-matter 是 markdown 文件最上方以---分隔的区域，用于指定个别档案的变数。\nPage Front-matter 用于页面配置 Post Front-matter 用于文章页配置 如果标注可选的参数，可根据自己需要添加，不用全部都写\nPage Front-matter：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 --- title: date: updated: type: comments: description: keywords: top_img: mathjax: katex: aside: aplayer: highlight_shrink: --- 写法 解释 title 【必需】页面标题 date 【必需】页面创建日期 type 【必需】标籤、分类和友情链接三个页面需要配置 updated 【可选】页面更新日期 description 【可选】页面描述 keywords 【可选】页面关键字 comments 【可选】显示页面评论模块(默认 true) top_img 【可选】页面顶部图片 mathjax 【可选】显示mathjax(当设置mathjax的per_page: false时，才需要配置，默认 false) kates 【可选】显示katex(当设置katex的per_page: false时，才需要配置，默认 false) aside 【可选】显示侧边栏 (默认 true) aplayer 【可选】在需要的页面加载aplayer的js和css,请参考文章下面的音乐 配置 highlight_shrink 【可选】配置代码框是否展开(true/false)(默认为设置中highlight_shrink的配置) Post Front-matter：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 --- title: date: updated: tags: categories: keywords: description: top_img: comments: image: toc: toc_number: toc_style_simple: copyright: copyright_author: copyright_author_href: copyright_url: copyright_info: mathjax: katex: aplayer: highlight_shrink: aside: --- 写法 解释 title 【必需】文章标题 date 【必需】文章创建日期 updated 【可选】文章更新日期 tags 【可选】文章标籤 categories 【可选】文章分类 keywords 【可选】文章关键字 description 【可选】文章描述 top_img 【可选】文章顶部图片 cover 【可选】文章缩略图(如果没有设置top_img,文章页顶部将显示缩略图，可设为false/图片地址/留空) comments 【可选】显示文章评论模块(默认 true) toc 【可选】显示文章TOC(默认为设置中toc的enable配置) toc_number 【可选】显示toc_number(默认为设置中toc的number配置) toc_style_simple 【可选】显示 toc 简洁模式 copyright 【可选】显示文章版权模块(默认为设置中post_copyright的enable配置) copyright_author 【可选】文章版权模块的文章作者 copyright_author_href 【可选】文章版权模块的文章作者链接 copyright_url 【可选】文章版权模块的文章连结链接 copyright_info 【可选】文章版权模块的版权声明文字 mathjax 【可选】显示mathjax(当设置mathjax的per_page: false时，才需要配置，默认 false) katex 【可选】显示katex(当设置katex的per_page: false时，才需要配置，默认 false) aplayer 【可选】在需要的页面加载aplayer的js和css,请参考文章下面的音乐 配置 highlight_shrink 【可选】配置代码框是否展开(true/false)(默认为设置中highlight_shrink的配置) aside 【可选】显示侧边栏 (默认 true) 注意：我的博客根目录路径为 【D:/Blog/】，下文所说的根目录都是此路径，将用[BlogRoot]代替。\n标签页 前往你的Hexo博客根目录，打开Git Bash执行如下命令：\n1 hexo new page tags 在[BlogRoot]\\source\\会生成一个含有index.md文件的tags文件夹。\n修改[BlogRoot]\\source\\tags\\index.md，添加type: \u0026quot;tags\u0026quot;。\n1 2 3 4 5 --- title: tags date: 2022-10-28 12:00:00 type: \u0026#34;tags\u0026#34; --- 友情链接 前往你的Hexo博客根目录，打开cmd命令窗口执行如下命令：\n1 hexo new page link 在[BlogRoot]\\source\\会生成一个含有index.md文件的link文件夹\n修改[BlogRoot]\\source\\link\\index.md，添加type: \u0026quot;link\u0026quot;\n1 2 3 4 5 --- title: link date: 2024-4-29 12:00:00 type: \u0026#34;link\u0026#34; --- 前往[BlogRoot]\\source\\_data创建一个link.yml文件（如果沒有 _data 文件夹，请自行创建），并写入如下信息（根据你的需要写）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 - class_name: 1.技术支持 class_desc: 本网站的搭建由以下开源作者提供技术支持 link_list: - name: Hexo link: https://hexo.io/zh-cn/ avatar: https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg descr: 快速、简单且强大的网志框架 siteshot: https://source.fomal.cc/siteshot/hexo.io.jpg - class_name: 2.友情链接 class_desc: 一些好朋友~~ link_list: - name: Fiveth link: https://blog.fiveth.cc/ avatar: https://p.fiveth.cc/avatar.jpg descr: 分享知识与生活 siteshot: https://p.fiveth.cc/siteshot.jpg class_name和class_desc支持 html 格式，如不需要，也可以留空。\n子页面 子页面也是普通的页面，可以使用hexo new page xxx创建页面。\n404页面 主題內置了一个简单的404页面，可在设置中开放。\n如需本地预览，请访问 http://localhost:4000/404.html\n1 2 3 4 5 ## A simple 404 page error_404: enable: true subtitle: \u0026#34;页面沒有找到\u0026#34; background: ","date":"2024-04-29T21:33:53Z","image":"https://p.fiveth.cc/img/m/hexo.jpg","permalink":"https://blog.fiveth.cc/p/138e/","title":"Hexo搭建进阶：Vercel部署、主题安装、基础用法"},{"content":"{% tip sync %}4.23 今天是世界读书日📖{% endtip %}\n正好最近我最近开始记录阅读，规划读书。\n这篇文章就和大家聊聊我的读书方法\n为什么读书 以前我都是看视频获取知识的，在这个时代，通过短视频在很短时间获得大量信息。\n但现在我开始阅读，通过书籍去学习。为什么呢？\n书籍是作者花几年时间写的，而视频通常只是几天时间做出的。 书中大量的举例、解释，让我们对知识了解更通透。 自己提取出来的知识，印象才会深，记得深。 读书可以进入心流状态，提高专注力。在这个快节奏的时代，离开手机，读读书，可以让我们慢下来。 我只列出了几个点，读书的原因有很多，许多名人都推荐我们读书。\n我的博客书单页面 我给博客开了一个我的书单页面，记录我每个月的阅读书籍。\n用的是anzhiyu主题里面的装备页面改的。\n我的读书笔记 我每读一本书，都会用一面A5纸做一个读书笔记。\n对，就是一面A5纸，我会把笔记的量控制在这张纸中。为什么呢？\n因为我们的记忆是有限的。很多人在读书后会做大量的梳理、思维导图，但大部分人只是将作者的思路框架重新理了一遍，告诉自己搞懂了。之前我也试过做全书梳理的笔记，结果发现自己没有记住书中的多少知识，并且也不愿意再翻那长长的笔记。\n实际上，一本书，只要有一个点让我们受到感触，并让我们去行动了，那它就发挥了巨大的价值。在读完后只记下最受感触的几个点，并尝试将他们运用起来，做出改变。而不是大量梳理，告诉自己我懂了。\n我之前的文章 一本让我开始觉醒的书：《认知觉醒》中有讲过\n我用什么读书 每次看完书都要重新在网上买书，等快递。\n所以之前我会用iPad读书，书籍我都是从Zlibrary下载。但是，阅读时长上去之后，眼睛看久了会疲劳，伤视力。于是，我就买了个电纸书：\n我现在用的是kindle kwp3，某鱼330💰入手的，非常小巧可爱，白色的颜值非常高。可以拿着在地铁上看书。\n我一般都是从zlibrary下书，而且还可以保存在amazon的图书馆云端上，要读的时候再下载。\n{% tip info %}读书是一生的习惯，让我们一起读书吧📖。{% endtip %}\n","date":"2024-04-23T13:48:27Z","image":"https://p.fiveth.cc/img/m/lowsun.webp","permalink":"https://blog.fiveth.cc/p/ef0e/","title":"读书日：聊聊我的读书方法"},{"content":"这是我第二次考雅思，考了7分。全靠听力8.5拉的分，口语甚至只考了个5.5，非常离谱。我对这份成绩是有些失望的，尤其是口语给我整无语了。\n我第一次考的是6.5分，当时口语还有6，这次给了个5.5，我个人认为发挥是差不多的，可能是考官的判断问题。值得一提的是我踩了个雷，在有一个问题的时候，我刚回答了个Of Course，之后考官立马地打断我，问下一个问题。当时我非常疑惑，回头考完一查发现Of Course是非常不礼貌的，意思相当于“这不废话吗”😅。\n非常可惜，口语小分没有到大学申请标准，如果有6的话，这份成绩单至少可以用来保底。但是没关系，我的目标不局限于此，暑假的时候我会做好准备后再考一次，争取总分7.5，小分6.5。\n不过听力稳定发挥了我的平常实力，还是很好的。给大家分享以下我学习英语的一些小方法：\n看英语视频，老生常谈了，但是有要点，就是去看自己感兴趣的内容，比如我平时喜欢在b站看教学视频，那不妨去Youtube上看看，可以找到更多优质的内容。为了学习视频中讲的内容，我就会认真去听，并且思维模式也会跟着作者的英语走。这个时候英语就是我用来学习其他东西的工具/媒介，练习英语只是顺带着。\n我还发现一个非常有用的方法，就是用英语写日记。如果你已经有写日记的习惯，那可以试试改成用英语写，这个方法非常有效，你在表达自己想法和情绪的时候，就必须用英语组织出来，遇到不会讲的也会去查了然后写上去。只需要坚持几天，就会发现自己有时候思考是用英语思考的，非常有意思。\n总结发现，这两个方法都是将英语作为一种工具去使用，顺带着用英语去做别的事，而不用特意的去学习，我认为这是很好的方法。非常适合真正、长期地地提升英语硬实力，但是如果是应对考试之类的，还是专项训练会效率比较高。\n","date":"2024-04-20T20:24:00Z","image":"https://p.fiveth.cc/img/2024/0420213033.jpg","permalink":"https://blog.fiveth.cc/p/938f/","title":"雅思7分的教训：听力8.5，口语踩雷"},{"content":"最近我读了《认知觉醒》这本书，作者是周岭。我非常感谢这本书，对我帮助非常大。如果你想改变自己现在的生活，变得更加优秀，这本书一定会帮到你。书中给出了许多提升自己的方法，其中的每个章节都让我有所感悟。这篇文章我会讲其中一些让我最受感触的点。\n元认知 书中提到了“元认知”这个概念，当我们开启元认知，就会不断的进步、提升。开启元认知，就是开启第三人称，时刻审视自己在做什么、在想什么。有了这种觉知，你就会在玩游戏的时候意识到自己正在过度放纵，并且思考自己的大脑为什么会沉迷于游戏当中；当你分手后无比沮丧的时候，就会思考自己现在处于一个怎样的状态，为什么不开心。当你开启这样一个能力之后，你就会无限进步，你能一直审视自己的行为和思维，在错误的时候意识到并改进。这就相当于自己开了上帝视角，时刻地在监督自己。\n当你知道了这个概念之后，你就可以开始行动、练习，时刻审视自己。当你受到任何感触，比如开心或沮丧时，问问自己是什么原因，这会让你变得更加了解自己。最近我看到一个句子让我很有感触，\u0026quot;who looks outisde, dreams; who looks inside, awakes.\u0026quot;-Carl Jung，当你开始挖掘自己内心时，你就会清醒，明白自己到底想要什么，了解自己的思维方式，这会帮你打开自我提升的大门。写日记、写每日反思是一个很好的方法，在每天的结尾反思自己做了什么，无需置疑，这绝对是一个改变终身的习惯，孔子说过”吾日三省吾身“。其次，练习元认知最好的方法是冥想，具体关于冥想的知识，大家可以自行去搜索，之后我会单独写一篇文章来讲我的冥想心得，总之这是一个非常有益的习惯，在冥想中，我们会练习将注意力放在呼吸和身体上，当有杂念的时候，我们就需要意识到并注意力拉回。可见冥想是练习元认知能力最直接的方法。\n行动 ”真正的成长不在于自己懂了多少道理，而在于自己做了多少改变“\n很多时候，我们会从书中或者视频中学到很多知识，在读后我们都会恍然大悟，觉得很有道理，但是，你可以回忆一下其中有多少是你真正为之做出改变的，运用到了生活之中的。我们很容易就会陷入到只停留在懂了，但没有去做的阶段。所以，当你学到任何知识让你受到感触的，那就开始行动，思考如何做出改变。这个道理很使用于读书，很多人读书会做大量的笔记，甚至思维导图，但他们只是将作者的思路整理列了个大纲，而在做完之后他们认为懂了就再也没翻阅过，即使翻阅，大量的内容也会让他们头晕目眩，这点我也深有感悟。真正好的读书方法是：\n在书中取一个你最受感触的点并为之做出改变，这远远比你把一大堆知识记下来要有用得多。想想，一本书只要让你改变了一点点，那它就已经发挥了它的巨大价值。\n所以，在读完这本书后我改进了自己的读书方法，在读完后只记下最受感触的几个点，并尝试将他们运用起来，做出改变。而不是大量梳理（可能适用于课程学习，但肯定不适用于读书），告诉自己我懂了。其次，我为什么会写这篇文章，分享读书知识，那就是费曼学习法。\n费曼 费曼学习法就是将自己学到的知识，用自己的话讲述给他人，在这个过程中知识会在你的大脑中得到加工和巩固，如果你能非常清晰地讲述给他人，那说明你真正懂了。这本书我是上周读的，而我现在并没有拿着这本书写博客，我只是将自己从这本书中得到的最受感触的，进入我记忆中的，用自己的话写了出来。\n关联 能与自己产生关联的知识，是记得最深的。从一本书中你可能会学到很多有道理的知识，但你不一定会记住每一个。这个知识需要和你以往某个经历，或者存在于你知识体系中的某个点练习起来，才会被记得非常深。如果和你大脑中的知识没有任何关联，即使很有道理，也很容易忘记。所以，利用好这点，当你看到某个很受感触的知识时，有什么你已知的知识与其相关联，将你的想法记下来。如果你现在是一个学生，你读到职场的一些知识，那么就把它先放一放吧。\n以上就是这本书我深受感触的一些知识点，当然这些只是对我来说最受感触的，和我有关联的，其中还有非常多有用的知识，非常推荐大家自行去阅读这本书。如果大家喜欢这篇文章，可以关注本站，我会每周分享自己读到的好书。\n","date":"2024-04-14T21:57:47Z","image":"https://p.fiveth.cc/img/2024/0518114933.jpg","permalink":"https://blog.fiveth.cc/p/9c7a/","title":"一本让我开始觉醒的书：《认知觉醒》"},{"content":"今天整理博客，发现我给文章取的文件名比较混乱，要找文章的时候会很不方便。\n一般我们都是用hexo new file_name创建文章的md文件的，然后文章的标题是在md文件的信息栏定义的。而我们很多时候是开始写文章才想好标题，随着写作标题也会发生变动，这导致最后我们文章标题和文件名是不同的，加大了我们的管理难度。\n所以我们会在改动文章标题的时候，将文件名也改成一样的。但是这样手动改非常麻烦。因此我配合ChatGPT用Python写了个一键批量修改文件名的小脚本。这样我们就可以很方便的一键将文件名全部都同步成文章的标题。\n使用方法 方法1. exe文件 脚本已经打包成exe文件，大家可以直接下载使用，下载后放到_posts文件夹下运行即可。\nhttps://wwf.lanzoum.com/icY4q1ufi7na 密码:ff6u\n注意：如果标题中有不支持的特殊符号，会导致运行失败。可以往下看，自行用python调整源代码后运行\n记得运行完后将脚本移出文件夹，防止被上传。\n方法2. python运行 如果有调试需求，大家也可以自己用python编译使用。\n下面是方法：\n首先要安装python。\n在_posts文件夹中创建一个rename.txt文件，复制粘贴下列代码进去：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import os dir_path = \u0026#34;./\u0026#34; i = 0 for file in os.listdir(dir_path): ## Skip \u0026#39;.\u0026#39; and \u0026#39;..\u0026#39; if file == \u0026#34;.\u0026#34; or file == \u0026#34;..\u0026#34;: continue ## Construct the full path to the file file_path = os.path.join(dir_path, file) ## Read the file try: with open(file_path, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: lines = f.readlines() except UnicodeDecodeError: print(f\u0026#34;Skipping file due to encoding issue: {file}\u0026#34;) continue ## Skip files with less than 2 lines if len(lines) \u0026lt; 2: continue ## Extract and process the title from the second line title = lines[1].strip().replace(\u0026#39;title:\u0026#39;, \u0026#39;\u0026#39;).strip() ## Remove any marks from the title title = title.replace(\u0026#39;?\u0026#39;, \u0026#39;\u0026#39;) title = title.replace(\u0026#39;|\u0026#39;, \u0026#39;-\u0026#39;) ## Rename new_filename = title + \u0026#39;.md\u0026#39; new_file_path = os.path.join(dir_path, new_filename) os.rename(file_path, new_file_path) i += 1 print(i) 然后将文件名后缀修改成.py\n在文件夹空白处右键，点击在终端中打开\n在终端中输入python rename.py即可运行脚本\n自己做脚本优化了一下博客工作流，成就感满满。\n另外，去年我一直是随缘更博客，接下来我会开始有规律性的定期发文章，分享我的生活和学习到的知识。做博客的精髓在于长期坚持，一直有新内容才会有人关注。一起加油吧😊\n","date":"2024-04-09T11:51:10Z","image":"https://p.fiveth.cc/img/m/hexo.jpg","permalink":"https://blog.fiveth.cc/p/fbe8/","title":"Hexo博客优化：批量修改md文件名"},{"content":"使用Thinkbook14+也有两年了，我是在22年买的。后悔自己买的太早，因为22年酷睿款的续航十分鸡肋（23及24款在续航有很大提升），相信一样用这款的朋友们应该深有体会。离电不到2小时的续航，堪比游戏本。作为一个学生，在学校中基本上只能离电使用，所以我对续航有一定需求。\n在我的一番调教下，它的续航最终达到了静置10小时，低负办公8小时的理论成绩。这对我日常使用体验的提升非常大，终于不用再频繁地把电脑放到充电仓。今天就来分享一下我自用的续航调教方案。本篇部分适用于所有笔记本，部分是针对22 Thinkbook14+酷睿版的。\n文章部分参考自【知乎】2022款ThinkBook 14+/16+酷睿版的电池续航优化更新\n基础 在离电使用时，做如下设置延长电池续航：\nFn+Q 切换到节能模式（显示电池图标的那个） Fn+空格键 关闭键盘背光 Fn+R把屏幕刷新率调整为60Hz（配置了高刷屏的机型） 右键点击屏幕右下角的电池图标打开电源和睡眠设置，将电源模式设置为最佳能效 打开节电模式 不使用蓝牙时就关掉（WIFI同理） 适当降低屏幕亮度 更新驱动 近期，官方在驱动程序上对22酷睿款更新了优化续航的措施，我们需要上官网下载更新。操作如下：\n进入官网Lenovo服务与支持\n在搜索框中输入自己的机型（机型可以在笔记本机身底部找到）\n比如我的是ThinkBook 14 G4+ IAP\n点击驱动下载\n下载以下程序的最新版本并安装\nBIOS升级程序 （IAP - HYCN45WW或ARA - J6CN46WW之后版本） Intel显卡驱动 （23/9/27之后版本） 主板Lenovo Dispatcher-Basic 驱动程序（23/9/27之后版本） 关闭独显 我的机型搭载了独显Nvidia，独显的耗电量是非常大的，我试过用软件让独显强制睡眠，但是监测显示独显仍有耗电。\n所以最后干脆直接在BIOS中关闭独显，以最大程度提升续航，操作如下：\n重启电脑，在开机页面按Enter 按F1进入BIOS控制面板 显示模式选择集显模式 退出并保存 现在我们在桌面右键打开更多选项，就会发现Nvidia控制面板没了，我们成功关闭了独显。\n之后若要开启使用，还是一样的操作进入BIOS调回混合模式即可。\nThrottleStop Throttlestop是一个CPU调节工具，可以用来超频/降频/降温/降压。中文版下载\n上面四个选项是选择不同场景，可以分别配置不同场景下的参数，场景的名字可以在设置中自定义。下面是配置选项，这里我们只需要用到Speed Shift EPP（变速EPP）。EPP 允许设置范围为0~255，数值越大越省电，数值越小性能越好。\n这里给大家参考下我的四个场景配置：\n性能：高性能，EPP 32 插电：平衡，EPP 128 离电：省电模式，EPP 192 节能：省电模式，EPP 255 设置开启自动启动\n在桌面右键此电脑，点击管理 左侧展开任务计划程序，点击任务计划程序库 右侧创建任务 取名”Throttlestop“ 触发器页面，新建选择当任何用户登陆时 操作页面，新建然后点击浏览，找到并选择Throttlestop.exe 条件页面，取消勾选只有在计算机使用交流电源时才启动此任务 如果需要进一步提升续航，还可以在FIVR中限制CPU的电压，硬核延长续航，此操作有一定风险，并且新版BIOS限制了电压控制的功能，还需要先解锁电压控制，此处不做展开。\n我的个人调教方案到这里就结束了，我们已经非常大程度提升了续航，可以带着笔记本出门放心耍啦😎\n","date":"2024-02-27T16:03:50Z","image":"https://p.fiveth.cc/img/m/thinkbook-battery-cover.jpg","permalink":"https://blog.fiveth.cc/p/4b21/","title":"2022款Thinkbook14+酷睿版续航优化方案"},{"content":"基础 小习惯的大力量 一个微小的习惯改变，会对未来影响很大。 每天进步1%，一年就是很多。 专注于系统，而不是目标。\n基于身份的习惯比基于目标的习惯更有效 自己想成为什么样的人 用习惯去证明自己是这样的人 习惯形成的4个步骤： 提示，渴望，反应，奖励。\n例子：你起床(提示)，想要清醒(渴望)，所以喝了杯咖啡(反应)，满足了清醒的需求(奖励)。\n建立好习惯：让提示更明显，让渴望更吸引，让反应更简单，让奖励更令人满意。 打破坏习惯：让提示不明显，让渴望不吸引，让反应更困难，让奖励更令人不满。\n1st law—让提示更明显 加强对习惯的意识 写习惯清单：把自己现有的习惯全写上去，并做好坏评估。\nPointing-and-calling：把自己接下来要做的事和结果大声说出来。这样可以增强意识。\n例子：\n“明天五点我要去邮政局” “我现在要吃饼干，但是我并不需要，这会让我变胖。” 让提示更明显的两个方法 Implementation intension(执行意向)公式：“I will [BEHAVIOR] at [TIME] in [LOCATION].”\nHabit stacking(习惯堆叠)公式：“After [CURRENT HABIT], I will [NEW HABIT].”\n环境比动力更重要 让好习惯的提示更明显：\n把要阅读的书放在桌子上显眼的地方\n把游戏手柄放隐蔽的地方\n给特定环境关联特定习惯：\n在床上就睡觉，在桌上就学习 （尽量给一个环境只关联一个习惯）\n借助环境远离坏习惯 依靠自控力只是一个短期的方法，我们需要环境配合才能更长久，要远离坏习惯的提示。\n例子：\n写作业效率不高，就把手机放在另一个房间一段时间。 花钱买太多东西，就不要刷淘宝。 老玩游戏，就把手柄放在看不到的地方。 2nd law 让它更吸引 诱惑捆绑 把需要做的和想做的事关联起来\nhabit stacking + temptation bundling公式: After [CURRENT HABIT], I will [HABIT I NEED]. After [HABIT I NEED], I will [HABIT I WANT].\n加入好的圈子 加入你想建立的习惯在他们之中是常态的圈子，我们会被所处圈子影响\n找到你和圈子中的人的相同特征，这会让你有归属感\n激励仪式 创造一个激励仪式在困难习惯之前做，给好习惯关联上积极的情感。\n例子：每次玩游戏前深呼吸然后笑，之后在写作业前也这样做。\n3rd law 让它更简单 开始行动，不断重复习惯，不要纸上谈兵 调整环境，让习惯更简单。每次做完习惯之后，都为下一次习惯做好准备。\n例子：\n想健身，提前把装备准备好。 想写作业，提前把作业放在桌上。 玩游戏，就把手柄锁柜子里。 善用决定性时刻，用小行为决定走向。 当你穿上了跑鞋，就说明你决定了你接下来会去跑步。\n这会减少拖延和犹豫。\n两分钟规则 简化习惯，所有习惯都能简化成在两分钟内完成的形式。 建立起习惯后，再去提升时长和质量。 例子：\n每天读一页书。 穿上跑步鞋。 自动化你的习惯 投资锁定未来行为的技术和一次性购买。\n例子：买健身房卡，这会迫使你未来常去锻炼。\n4th law 让它更令人开心 即使奖励 给好习惯增加立即能获得的奖励，给坏习惯增加立即会得到的惩罚。\nThe Cardinal Rule of Behavior Change:\nWhat is immediately rewarded is repeated. What is immediately punished is avoided.\n例子：记账“去旅游”，每少吃一次大餐就往里存50元。\n视觉化进度 视觉化习惯的完成进度，增加每次做完后的成就感\n例子：健身记录，读书页码，读书打卡\nHabit Tracking(习惯记录)\nThe habit stacking + habit tracking公式:\nAfter [CURRENT HABIT], I will [TRACK MY HABIT].”\n注意：不要因过度重视记录的次数，而忽略了习惯的质量和本身的目的。\n习惯中断要立即重拾 不要连续缺勤两次，习惯中断要立即重拾\n习惯违反合同 找一个搭档，监督你的行为。\n建立习惯合同，让违反承诺的代价变得公开和痛苦。\n高级策略 选择适合自己的习惯 每个人都有自己的人格，有自己适合做的事情，要取长补短。\n选择适合自己的习惯，会更好坚持。\n忍受无聊 成功在于能忍受无聊。\n任何人在感到有动力时都可以努力工作。只有在没有动力的时候，还能坚持下去，才会超越他人。\n习惯的弊端 养成习惯之后，很容易停止去思考和提升。\n我们要定期做反思和回顾，时刻注意自己的表现。\n","date":"2023-11-23T16:07:26Z","image":"https://p.fiveth.cc/img/m/habits.jpg","permalink":"https://blog.fiveth.cc/p/a76a/","title":"阿谦读书笔记：《原子习惯》"},{"content":"对一个网站来说，性能是非常重要的，它决定了用户在网页停留的时长。\n如果网页的加载速度很慢的话，用户很容易就会离去。\n有朋友说我的博客速度挺快的，这篇文章就讲讲我是如何优化我的网站性能的。\n性能检测 首先我们可以使用网站性能检测工具，来获取网站的性能报告，这样我们就可以知道是哪部分拖慢了网站速度，从而对其进行优化。\n我用的工具是Chrome开发者工具中自带的Lighthouse，给出性能报告的同时，它还会给出一些优化的建议。\nVercel网站托管 我使用的是Vercel来托管我的网站，它在全球以及国内都有非常优秀的速度。如果想要让其在国内可以浏览的话，需要准备一个域名。\n具体如何使用可以参考Fomalhaut的文章Hexo博客搭建基础教程(二)中有详细教程。\n注意：cname的解析方法目前会导致无法在国内访问，需要做一些修改 **失效方法：**记录值类型cname，值为cname.vercel-dns.com **解决方法：**记录值类型A类型，值为76.223.126.88\nVercel加速节点（新） {% note info flat %}此章为2024.4新添加内容{% endnote %}\n这是一个vercel加速节点，使用是会自动解析至附近可用节点，尽可能的选择优质节点。\n食用方法：将原来解析至 cname.vercel.com 改为 vercel.cdn.yt-blog.top（CNAME记录）\n由Fgaoxing提供，原文链接：【推一下Vercel加速节点】\n图片压缩 在我们的博客中，最消耗流量的应该就是图片了。所以为了提升加载速度，对图片的压缩非常重要。\n1.每次将图片上传到图床之前，我都会对其进行压缩（控制在50kb以下）\n2.同时，将图片转换成webp格式也会大大提高加载速度。\n这里推荐一个我一直在用的多功能在线图片压缩工具，非常方便快捷。\nlazyload **lazyload(懒加载)**是一个对提升性能非常有效的功能，它会优先加载处于屏幕显示区域内的资源，而不是等待一整个页面的资源加载完毕。这让许多资源可以在用户边浏览的时候边加载，节省时间。\n我给我的评论模块开启了lazyload，因为很多时候评论模块加载都会慢，导致用户要在加载页面等待。\ngulp压缩 gulp插件可以帮助我们自动压缩博客静态资源。\n具体如何安装使用可以参考Akilar的文章【使用gulp压缩博客静态资源】\nCDN 让所有的静态资源通过**CDN(内容分发网络)**加载，可以提高资源加载速度。\n我使用的是HEO大佬分享的【Butterfly CDN链接更改指南】中给出的cdn\n这里给出我在butterfly中的cdn列表：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 pjax: https://lib.baomitu.com/pjax/0.2.8/pjax.min.js twikoo: https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/twikoo/1.4.18/twikoo.all.min.js sharejs: https://lib.baomitu.com/social-share.js/1.0.16/js/social-share.min.js sharejs_css: https://lib.baomitu.com/social-share.js/1.0.16/css/share.min.css lazyload: https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/vanilla-lazyload/17.3.1/lazyload.iife.min.js instantpage: https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/instant.page/5.1.0/instantpage.min.js typed: https://lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/typed.js/2.0.12/typed.min.js snackbar_css: https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/node-snackbar/0.1.16/snackbar.min.css snackbar: https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/node-snackbar/0.1.16/snackbar.min.js fontawesome: https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/6.0.0/css/all.min.css justifiedGallery_js: https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js justifiedGallery_css: https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/justifiedGallery/3.8.1/css/justifiedGallery.min.css aplayer_css: https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.css aplayer_js: https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.js meting_js: https://npm.elemecdn.com/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js 总结 这些大概就是我对我的网站做的优化总结了，其实还有很多地方可以再提升，但是对我来说已经够用了。\n希望大家都可以积极地去优化网站的性能，这样才可以收获更多的游客🙂\n","date":"2023-10-11T12:06:31Z","image":"https://p.fiveth.cc/img/m/perf.jpg","permalink":"https://blog.fiveth.cc/p/95d6/","title":"Hexo博客优化：如何优化Hexo的网站性能？"},{"content":"经常白嫖游戏的小伙伴应该都对3DM不陌生，里面有很多盗版游戏资源。但是呢，很多3dm下来的游戏都要用3dm启动器去打开，你说用你启动器打开就算了，就多点两下的事对吧。但是每次打开你启动器，你都要下载个“笑傲江湖”到我电脑里，删了还没用，下次启动的时候又会跳出来，这跟流氓软件有什么区别。今天就教大家怎么摆脱3DM流氓启动器，直接打开游戏。\n首先我们打开3dm启动器目录，如图，打开3dmConfig.ini文件，找到游戏exe文件的路径。\n接下来我们顺着路径去寻找，会发现根本就找不到游戏的exe文件。别慌，这是3dm耍的小把戏，把游戏启动的exe文件给隐藏了。我们要做的就是把被隐藏的文件给显示出来。\n我们打开cmd窗口，进入对应的目录，然后执行dos命令：\n如何打开cmd窗口？win+r，然后输入cmd，点确定\n1 attrib -s -a -h -r wwzRetailEgs.exe 然后我们就能看到游戏的exe文件在目录中显示出来了，我们可以右键然后将快捷方式创建到桌面，之后我们就不需要用3dm启动器来打开游戏了😎。\n","date":"2023-06-06T22:15:15Z","image":"https://p.fiveth.cc/img/m/3dm.jpg","permalink":"https://blog.fiveth.cc/p/134b/","title":"摆脱3DM启动器打开游戏：避免捆绑下载笑傲江湖"},{"content":"本篇将学习OpenGL中关于纹理的各种知识。纹理就是图片，用于给模型添加细节。\n纹理环绕方式 如果我们把纹理坐标设置在范围之外会发生什么？OpenGL默认的行为是重复这个纹理图像。下面更多的选择：\n环绕方式 描述 GL_REPEAT 对纹理的默认行为。重复纹理图像。 GL_MIRRORED_REPEAT 和GL_REPEAT一样，但每次重复图片是镜像放置的。 GL_CLAMP_TO_EDGE 纹理坐标会被约束在0到1之间，超出的部分会重复纹理坐标的边缘，产生一种边缘被拉伸的效果。 GL_CLAMP_TO_BORDER 超出的坐标为用户指定的边缘颜色。 设置坐标轴环绕方式（s、t（如果是使用3D纹理那么还有一个r））\n1 2 glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT); 如果选择GL_CLAMP_TO_BORDER选项，需要指定一个边缘的颜色。\n1 2 float borderColor[] = { 1.0f, 1.0f, 0.0f, 1.0f }; glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor); 纹理过滤 如何将纹理像素(Texture Pixel)映射到纹理坐标，让分辨率清晰\n纹理过滤有很多个选项，但是现在我们只讨论最重要的两种：\nGL_NEAREST 邻近过滤 (Nearest Neighbor Filtering):\n选择中心点最接近纹理坐标的那个像素\nGL_LINEAR 线性过滤 (linear Filtering):\n基于纹理坐标附近的纹理像素，计算出一个插值 (心距离纹理坐标越近,贡献越大)\n效果对比 我们可以在纹理被缩小的时候使用邻近过滤，被放大时使用线性过滤。方法：\n1 2 glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); 多级渐远纹理 (Mipmap)：一系列的纹理图像，后一个纹理图像是前一个的二分之一。\n功能：提升真实性、提升性能。\n过滤方式 描述 GL_NEAREST_MIPMAP_NEAREST 使用最邻近的多级渐远纹理来匹配像素大小，并使用邻近插值进行纹理采样 GL_LINEAR_MIPMAP_NEAREST 使用最邻近的多级渐远纹理级别，并使用线性插值进行采样 GL_NEAREST_MIPMAP_LINEAR 在两个最匹配像素大小的多级渐远纹理之间进行线性插值，使用邻近插值进行采样 GL_LINEAR_MIPMAP_LINEAR 在两个邻近的多级渐远纹理之间使用线性插值，并使用线性插值进行采样 设置方法：\n1 2 glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); 加载与创建纹理 将图像加载到应用中，需要自己写一个图像加载器，或者使用支持多种格式的图像加载库。\nstb_image.h stb_image.h下载链接\n将头文件加入你的工程，并在源文件中输入以下代码引入：\n1 2 #define STB_IMAGE_IMPLEMENTATION //让头文件只包含相关的函数定义源码 #include \u0026#34;stb_image.h\u0026#34; 接下来，我们用stb_image加载图片\n1 2 int width, height, nrChannels; unsigned char *data = stbi_load(\u0026#34;container.jpg\u0026#34;, \u0026amp;width, \u0026amp;height, \u0026amp;nrChannels, 0); 加载图片前我们为了防止图片颠倒输出，我们可以输入\n1 stbi_set_flip_vertically_on_load(true); //OpenGL会自动将图片颠倒，所以我们要上下翻转 生成纹理 创建纹理对象\n1 2 unsigned int texture; glGenTextures(1, \u0026amp;texture); 生成纹理\n1 2 glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data); glGenerateMipmap(GL_TEXTURE_2D); 第一个参数指定了纹理目标(Target)。设置为GL_TEXTURE_2D意味着会生成与当前绑定的纹理对象在同一个目标上的纹理（任何绑定到GL_TEXTURE_1D和GL_TEXTURE_3D的纹理不会受到影响）。 第二个参数为纹理指定多级渐远纹理的级别，如果你希望单独手动设置每个多级渐远纹理的级别的话。这里我们填0，也就是基本级别。 第三个参数：纹理储存格式。(RGB\\RGBA) 第四个和第五个参数设置最终的纹理的宽度和高度。 下个参数应该总是被设为0（历史遗留的问题）。 第七第八个参数定义了源图的格式和数据类型。我们使用RGB值加载这个图像，并把它们储存为char(byte)数组，我们将会传入对应值。 最后一个参数：图像数据。 最后还要释放图像内存\n1 stbi_image_free(data); 生成纹理的整个过程：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 unsigned int texture; glGenTextures(1, \u0026amp;texture); glBindTexture(GL_TEXTURE_2D, texture); // 为当前绑定的纹理对象设置环绕、过滤方式 glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); // 加载并生成纹理 int width, height, nrChannels; stbi_set_flip_vertically_on_load(true);//OpenGL会自动将图片颠倒，所以我们要上下翻转 unsigned char *data = stbi_load(\u0026#34;container.jpg\u0026#34;, \u0026amp;width, \u0026amp;height, \u0026amp;nrChannels, 0); if (data) { glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data); glGenerateMipmap(GL_TEXTURE_2D); } else { std::cout \u0026lt;\u0026lt; \u0026#34;Failed to load texture\u0026#34; \u0026lt;\u0026lt; std::endl; } stbi_image_free(data); 应用纹理 接下来我们来应用纹理，绘制一个带我的世界草块纹理的矩形：草块图片\n1 2 3 4 5 6 7 8 9 10 11 float vertices[] = { // ---- 位置 ---- ---- 颜色 ---- - 纹理坐标 - 0.5f, 0.5f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f, // 右上 0.5f, -0.5f, 0.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f, // 右下 -0.5f, -0.5f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, // 左下 -0.5f, 0.5f, 0.0f, 1.0f, 1.0f, 0.0f, 0.0f, 1.0f // 左上 }; unsigned int indices[] = { 0, 1, 3, // first triangle 1, 2, 3 // second triangle }; 在循环中绘制\n1 2 3 glBindTexture(GL_TEXTURE_2D, texture); glBindVertexArray(VAO); glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0); 我们的草块就出来了！\n我们再在草块上加上顶点颜色：修改片段着色器\n源代码：纹理应用源码\n1 FragColor = texture(ourTexture, TexCoord) * vec4(ourColor, 1.0); 纹理单元 纹理单元(Texture Unit)：纹理的位置值\n绑定前激活纹理单元：\n1 2 glActiveTexture(GL_TEXTURE0); // 在绑定纹理之前先激活纹理单元 glBindTexture(GL_TEXTURE_2D, texture); 我们来做个笑脸草块：\n先修改一下片段着色器：\n1 2 3 4 5 6 7 8 uniform sampler2D texture1; uniform sampler2D texture2; void main() { FragColor = mix(texture(texture1, TexCoord), texture(texture2, TexCoord), 0.2); //mix输出两个texture的混合值 } 再设置纹理单元\n1 2 3 ourShader.use(); glUniform1i(glGetUniformLocation(ourShader.ID, \u0026#34;texture1\u0026#34;), 0); //手动设置 ourShader.setInt(\u0026#34;texture2\u0026#34;, 1); 现在我们绑定多个纹理并绘制：\n1 2 3 4 5 6 7 glActiveTexture(GL_TEXTURE0); glBindTexture(GL_TEXTURE_2D, texture1); glActiveTexture(GL_TEXTURE1); glBindTexture(GL_TEXTURE_2D, texture2); glBindVertexArray(VAO); glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0); 就可以看到我们的笑脸草块了\n源代码：混合纹理源码\n","date":"2023-05-30T18:33:42Z","image":"https://p.fiveth.cc/img/m/grasscover.jpg","permalink":"https://blog.fiveth.cc/p/7cf1/","title":"OpenGL教学 | 3.如何给形状添加纹理，绘制各种带图案的形状？"},{"content":"本篇我们会更深入地了解着色器：\n学会着色器如何输入输出 学会使用Uniform，绘制会随时间变化颜色的图形 绘制彩色三角形 定义自己的着色器类 本文参考LearnOpenGL教学网站\n经验：建议打开源代码看着学习，光跟着文档的话思路会很乱\n下面是我做的笔记\n配合源码食用更佳🤫：OpenGL学习源码\n向量 数据类型：一般使用vecn（包含n个float分量的默认向量）\n重组（灵活的分量选择方式）：\n1 2 3 4 5 6 7 8 9 //重组的例子 vec2 someVec; vec4 differentVec = someVec.xyxx; vec3 anotherVec = differentVec.zyw; vec4 otherVec = someVec.xxxx + anotherVec.yxzy; vec2 vect = vec2(0.5, 0.7); vec4 result = vec4(vect, 0.0, 0.0); vec4 otherResult = vec4(result.xyz, 1.0); 输入与输出 我们给着色器加上输入和输出，让顶点着色器为片段着色器决定颜色。\n顶点着色器 1 2 3 4 5 6 7 8 9 10 #version 330 core layout (location = 0) in vec3 aPos; // 位置变量的属性位置值为0 out vec4 vertexColor; // 指定一个颜色输出 void main() { gl_Position = vec4(aPos, 1.0); // 注意我们如何把一个vec3作为vec4的构造器的参数 vertexColor = vec4(0.5, 0.0, 0.0, 1.0); // 把输出变量设置为暗红色 } 片段着色器 1 2 3 4 5 6 7 8 9 #version 330 core out vec4 FragColor; in vec4 vertexColor; // 从顶点着色器传来的输入变量（名称相同、类型相同） void main() { FragColor = vertexColor; } 现在运行，就可以看到我们成功将颜色由顶点着色器输入到片段着色器中，将三角形的颜色设置成了深红色。\nUniform Uniform是一种从CPU中的应用向GPU中的着色器发送数据的方式\n我们在片段着色器中声明Uniform\n1 2 3 4 5 6 7 8 9 #version 330 core out vec4 FragColor; uniform vec4 ourColor; // 在OpenGL程序代码中设定这个变量 void main() { FragColor = ourColor; } 现在，我们就可以在渲染循环中去改变三角形颜色了。这里我们用让它随时间变化颜色。\n1 2 3 4 5 float timeValue = glfwGetTime(); float greenValue = (sin(timeValue) / 2.0f) + 0.5f; int vertexColorLocation = glGetUniformLocation(shaderProgram, \u0026#34;ourColor\u0026#34;); glUseProgram(shaderProgram); glUniform4f(vertexColorLocation, 0.0f, greenValue, 0.0f, 1.0f); 源代码：Uniform源码\n你好，彩色三角形 现在，我们将把颜色数据添加为3个值至vertices数组。我们将把三角形的三个角分别指定为红色、绿色和蓝色。\n1 2 3 4 5 6 7 //顶点数据 float vertices[] = { // 位置 // 颜色 0.5f, -0.5f, 0.0f, 1.0f, 0.0f, 0.0f, // 右下 -0.5f, -0.5f, 0.0f, 0.0f, 1.0f, 0.0f, // 左下 0.0f, 0.5f, 0.0f, 0.0f, 0.0f, 1.0f // 顶部 }; 我们让顶点着色器接收颜色值，并输出到片段着色器。\n1 2 3 4 5 6 7 8 9 10 11 #version 330 core layout (location = 0) in vec3 aPos; // 位置变量的属性位置值为 0 layout (location = 1) in vec3 aColor; // 颜色变量的属性位置值为 1 out vec3 ourColor; // 向片段着色器输出一个颜色 void main() { gl_Position = vec4(aPos, 1.0); ourColor = aColor; // 将ourColor设置为我们从顶点数据那里得到的输入颜色 } 再修改一下片段着色器，让他输入颜色。\n1 2 3 4 5 6 7 8 #version 330 core out vec4 FragColor; in vec3 ourColor; void main() { FragColor = vec4(ourColor, 1.0); } 现在我们修改着色器的顶点格式。\n1 2 3 4 5 6 // 位置属性 glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0); glEnableVertexAttribArray(0); // 颜色属性 glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)(3* sizeof(float))); glEnableVertexAttribArray(1); 然后我们就可以看到一个彩色的三角形😍\n三角形会自动将我们给的三个顶点颜色进行渐变，这是在片段着色器中进行的所谓片段插值(Fragment Interpolation)的结果。\n源代码：彩色三角形源码\n自己的着色器类 管理着色器类是很麻烦的事，所以我们要写一个类来让我们能更轻松的管理。\n我们的着色器类用于：\n打开着色器文件 编译和链接着色器 use用来激活着色器程序 set用于设置和查询uniform 使用方法\n1 2 3 4 5 6 7 8 Shader ourShader(\u0026#34;path/to/shaders/shader.vs\u0026#34;, \u0026#34;path/to/shaders/shader.fs\u0026#34;); ... while(...) { ourShader.use(); ourShader.setFloat(\u0026#34;someUniform\u0026#34;, 1.0f); DrawStuff(); } 顶点和片段着色器的文件名可以任意取（推荐用shader.vs和shader.fs，很直观）\n源代码：着色器类源码\n恭喜你又学完了一篇教程🎉，你正在向目标一步一步地进发。\n","date":"2023-05-28T16:20:00Z","image":"https://p.fiveth.cc/img/m/colorcover.jpg","permalink":"https://blog.fiveth.cc/p/9641/","title":"OpenGL教程 | 2.了解着色器，并绘制彩色三角形"},{"content":"关于学习OpenGL OpenGL是学习计算机图形学的必备，虽然现在Vulkan是未来的OpenGL，但目前OpenGL仍是无法被替代的。\nVulkan学习难度过高，个人做项目太耗时间，所以OpenGL依旧是很好的选择。很多大神都认为，先学OpenGL打基础，在学习Vulkan的时候再将原先的知识进行分解转化，是个很好的方法。因为学习Vulkan时，想让屏幕上显示点东西需要做的工作太多了，非常容易放弃。(别说Vulkan了，OpenGL就已经够难了🤕)\n所以看了各论坛和思考后，我决定先上手OpenGL。\n这是一个非常好的OpenGL教学网站：英文版 | 中文版\n经验：建议打开源代码看着学习，光跟着文档的话思路会很乱\n下面是我做的笔记\n配合源码食用更佳🤫：OpenGL学习源码\n配置 因为OpenGL不支持，所以我们需要一个库用于显示窗口和处理用户输入 (如GLUT，SDL，SFML和GLFW)\n这里我们使用GLFW\nGLFW 一个专门针对OpenGL的C语言库。GLFW下载\n为确保完整性，下载源代码后用CMake编译。\nCMake 一个工程文件生成工具。Cmake下载\nglad 用于简化OpenGL获取函数地址的库。生成glad\n配置 在vs项目属性中指向include和lib文件夹\n将glad/src里的glad.c放入工程文件，并在vs中添加现有项\n在依赖项里加入\n1 glfw3.lib;opengl32.lib 你好，窗口 代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 #include \u0026lt;glad/glad.h\u0026gt; #include \u0026lt;GLFW/glfw3.h\u0026gt; #include \u0026lt;iostream\u0026gt; void framebuffer_size_callback(GLFWwindow* window, int width, int height); void processInput(GLFWwindow* window); //配置项 const unsigned int SCR_WIDTH = 800; const unsigned int SCR_HEIGHT = 600; int main() { //初始化glfw glfwInit(); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); // 创建glfw窗口 GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, \u0026#34;LearnOpenGL\u0026#34;, NULL, NULL); if (window == NULL) { std::cout \u0026lt;\u0026lt; \u0026#34;Failed to create GLFW window\u0026#34; \u0026lt;\u0026lt; std::endl; glfwTerminate(); return -1; } glfwMakeContextCurrent(window); //窗口变换 glfwSetFramebufferSizeCallback(window, framebuffer_size_callback); //glad加载opengl指针 if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) { std::cout \u0026lt;\u0026lt; \u0026#34;Failed to initialize GLAD\u0026#34; \u0026lt;\u0026lt; std::endl; return -1; } //渲染循环 while (!glfwWindowShouldClose(window)) { //处理输入 processInput(window); //渲染 glClearColor(0.2f, 0.3f, 0.3f, 1.0f); glClear(GL_COLOR_BUFFER_BIT); //glfw检查并调用事件，交换缓冲 glfwSwapBuffers(window); glfwPollEvents(); } // glfw清除 glfwTerminate(); return 0; } //输入处理函数 void processInput(GLFWwindow* window) { if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) glfwSetWindowShouldClose(window, true); } // glfw，窗口大小变换时自动调用 void framebuffer_size_callback(GLFWwindow* window, int width, int height) { glViewport(0, 0, width, height); } 源代码：窗口源码\n你好，三角形 现代Opengl渲染至少要设置一个顶点着色器和一个片段着色器。\n知识 VAO (顶点数组对象 Vertex Array Object) VBO (顶点缓冲对象 Vertex Buffer Object) EBO (元素缓冲对象 Element Buffer Object) 顶点着色器 Vertex Shader\n基础源码 1 2 3 4 5 6 7 #version 330 core layout (location = 0) in vec3 aPos; void main() { gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0); } 片段着色器 Fragment Shader 计算像素最后的颜色输出\n基础源码 1 2 3 4 5 6 7 #version 330 core out vec4 FragColor; void main() { FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f); //输出黄色 } 着色器程序 Shader Program Object\n链接多个着色器，将它们合并在一起。\n链接顶点属性 指定Opengl如何解释顶点数据。\n1 2 glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0); glEnableVertexAttribArray(0); 第一个参数：顶点属性。 第二个参数：顶点属性的大小。顶点属性是一个vec3，它由3个值组成，所以大小是3。 第三个参数：数据的类型，这里是GL_FLOAT(GLSL中vec*都是由浮点数值组成的)。 第四个参数：是否希望数据被标准化(Normalize)。如果我们设置为GL_TRUE，所有数据都会被映射到0（对于有符号型signed数据是-1）到1之间。我们把它设置为GL_FALSE。 第五个参数叫做步长(Stride)，它告诉我们在连续的顶点属性组之间的间隔。由于下个组位置数据在3个float之后，我们把步长设置为3 * sizeof(float)。要注意的是由于我们知道这个数组是紧密排列的（在两个顶点属性之间没有空隙）我们也可以设置为0来让OpenGL决定具体步长是多少（只有当数值是紧密排列时才可用）。（译注: 这个参数的意思简单说就是从这个属性第二次出现的地方到整个数组0位置之间有多少字节）。 最后一个参数：类型是void*，所以需要我们进行这个奇怪的强制类型转换。它表示位置数据在缓冲中起始位置的偏移量(Offset)。由于位置数据在数组的开头，所以这里是0。我们会在后面详细解释这个参数。 代码 硬编码着色器源码 定义全局变量\n1 2 3 4 5 6 7 8 9 10 11 12 13 //硬编码着色器源代码 const char* vertexShaderSource = \u0026#34;#version 330 core\\n\u0026#34; \u0026#34;layout (location = 0) in vec3 aPos;\\n\u0026#34; \u0026#34;void main()\\n\u0026#34; \u0026#34;{\\n\u0026#34; \u0026#34; gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\\n\u0026#34; \u0026#34;}\\0\u0026#34;; const char* fragmentShaderSource = \u0026#34;#version 330 core\\n\u0026#34; \u0026#34;out vec4 FragColor;\\n\u0026#34; \u0026#34;void main()\\n\u0026#34; \u0026#34;{\\n\u0026#34; \u0026#34; FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\\n\u0026#34; \u0026#34;}\\n\\0\u0026#34;; 配置着色器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 // 创建\u0026amp;编译 着色器 // ------------------------------------ // 顶点着色器vertex shader unsigned int vertexShader = glCreateShader(GL_VERTEX_SHADER); glShaderSource(vertexShader, 1, \u0026amp;vertexShaderSource, NULL); glCompileShader(vertexShader); // 检测错误 int success; char infoLog[512]; glGetShaderiv(vertexShader, GL_COMPILE_STATUS, \u0026amp;success); if (!success) { glGetShaderInfoLog(vertexShader, 512, NULL, infoLog); std::cout \u0026lt;\u0026lt; \u0026#34;ERROR::SHADER::VERTEX::COMPILATION_FAILED\\n\u0026#34; \u0026lt;\u0026lt; infoLog \u0026lt;\u0026lt; std::endl; } // 片段着色器fragment shader unsigned int fragmentShader = glCreateShader(GL_FRAGMENT_SHADER); glShaderSource(fragmentShader, 1, \u0026amp;fragmentShaderSource, NULL); glCompileShader(fragmentShader); // 检测错误 glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, \u0026amp;success); if (!success) { glGetShaderInfoLog(fragmentShader, 512, NULL, infoLog); std::cout \u0026lt;\u0026lt; \u0026#34;ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\\n\u0026#34; \u0026lt;\u0026lt; infoLog \u0026lt;\u0026lt; std::endl; } // 着色器程序(链接着色器) unsigned int shaderProgram = glCreateProgram(); glAttachShader(shaderProgram, vertexShader); glAttachShader(shaderProgram, fragmentShader); glLinkProgram(shaderProgram); // 检测错误 glGetProgramiv(shaderProgram, GL_LINK_STATUS, \u0026amp;success); if (!success) { glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog); std::cout \u0026lt;\u0026lt; \u0026#34;ERROR::SHADER::PROGRAM::LINKING_FAILED\\n\u0026#34; \u0026lt;\u0026lt; infoLog \u0026lt;\u0026lt; std::endl; } //删除前面的着色器 glDeleteShader(vertexShader); glDeleteShader(fragmentShader); // 链接顶点属性 // ------------------------------------------------------------------ float vertices[] = { -0.5f, -0.5f, 0.0f, // left 0.5f, -0.5f, 0.0f, // right 0.0f, 0.5f, 0.0f // top }; //VBO顶点缓冲对象，VAO顶点数组对象 unsigned int VBO, VAO; glGenVertexArrays(1, \u0026amp;VAO); glGenBuffers(1, \u0026amp;VBO); // 先绑定VAO，然后VBO，最后设置顶点属性指针 //bind the Vertex Array Object first, then bindand set vertex buffer(s), and then configure vertex attributes(s). glBindVertexArray(VAO); glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0); glEnableVertexAttribArray(0); // 解绑 glBindBuffer(GL_ARRAY_BUFFER, 0); glBindVertexArray(0); glBufferData参数:\nGL_STATIC_DRAW ：数据不会或几乎不会改变。 GL_DYNAMIC_DRAW：数据会被改变很多。 GL_STREAM_DRAW ：数据每次绘制时都会改变。 绘制三角形 在渲染循环中\n1 2 3 4 //画三角形 glUseProgram(shaderProgram); glBindVertexArray(VAO); glDrawArrays(GL_TRIANGLES, 0, 3); 然后就可以跟三角形说你好了！😎\n源代码：三角形源码\nHey，矩形 我们绘制两个三角形来组成一个矩形\n1 2 3 4 5 6 7 8 9 10 float vertices[] = { // 第一个三角形 0.5f, 0.5f, 0.0f, // 右上角 0.5f, -0.5f, 0.0f, // 右下角 -0.5f, 0.5f, 0.0f, // 左上角 // 第二个三角形 0.5f, -0.5f, 0.0f, // 右下角 -0.5f, -0.5f, 0.0f, // 左下角 -0.5f, 0.5f, 0.0f // 左上角 }; 但是，我们会看到，有两个顶点是重叠的，这回大大增加开销。所以我们要用到元素缓冲对象。\n元素缓冲对象 EBO 他存储 OpenGL 用来决定要绘制哪些顶点的索引\n1 2 3 4 5 6 7 8 9 10 float vertices[] = { 0.5f, 0.5f, 0.0f, // top right 0.5f, -0.5f, 0.0f, // bottom right -0.5f, -0.5f, 0.0f, // bottom left -0.5f, 0.5f, 0.0f // top left }; unsigned int indices[] = { // 从0开始! 0, 1, 3, // first Triangle 1, 2, 3 // second Triangle }; 可以看到现在只用存四个顶点数据\n和VAO,VBO一样，创建并绑到缓冲中\n1 2 3 unsigned int EBO; glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO); glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW); 然后在渲染循环中绘制\n1 2 3 4 // 绘制 glUseProgram(shaderProgram); glBindVertexArray(VAO); glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0); //绘制元素缓冲中的内容 然后我们就得到我们的矩形了\n我们还可以打开线框模式，显示矩形由两个三角形组成\n1 2 glPolygonMode(GL_FRONT_AND_BACK, GL_LINE) //G_LINE打开，GL_FILL关闭 源代码：矩形源码\n如果你也到这步了，那么恭喜你🎉，通过了OpenGL最难部分之一。\n接下来的路还很长，我们一起加油。\n","date":"2023-05-24T21:34:08Z","image":"https://p.fiveth.cc/img/m/openglcover.webp","permalink":"https://blog.fiveth.cc/p/8ca/","title":"OpenGL教程 | 1.如何上手OpenGL, 绘制三角形和矩形"},{"content":"学习TCP后用基于Qt TCP库做了一个联机小游戏🤼\n断断续续大概写了一周，程序源码放在文章底部了。\n结构思路 游戏通过服务端或者客户端进入，只支持两玩家。\n服务端进入：自己显示红色衣服，对方蓝色\n客户端进入：自己显示蓝色衣服，对方红色\n代码 位置传输 发送位置 将int[]转成QByteArray达到发送多数据的效果\n1 2 3 4 5 6 7 8 9 10 void Server::sendData(int x_self,int y_self,int dir_self) { if(isConnected){ //int[] 转 QByteArray int self[3] = {x_self,y_self,dir_self}; QByteArray array; array.append((char*)self, sizeof(int) * 3); socket.write(array); } } 接收位置 将QByteArray转成int[]\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void Server::receiveData() { // QByteArray 转 int[] QByteArray array=socket.readAll(); int data[3]; for (int i=0; i\u0026lt;3; i++) { int unTemp; memcpy(\u0026amp;unTemp, array.data() + sizeof(int) * i, sizeof(int)); data[i] = unTemp; } x=data[0]; y=data[1]; dir=data[2]; } 相对位置 自己始终显示在屏幕中间，只显示方向的改变。\n移动时改变坐标但不显示。\n游戏中的物体显示在 [屏幕中心坐标+物体坐标-自己坐标]\n物体包括：对方玩家，地图，树木\n1 2 3 4 5 //刷新函数，放在游戏主循环中 void Map::draw(int a,int b) //传入自己坐标 { map-\u0026gt;move(CENTER_X+x-a,CENTER_Y+y-b); //移动到相对位置 } 树木伪3D显示 很简单，当玩家y坐标大于树时显示在上，小于时显示在下。\n这段代码是有bug的，有两名玩家时，树木上下就会出现问题。\n主要是我没有找到将Label下移或者上移一层的函数，只有置顶和置底，所以代码逻辑很麻烦🤡。\n1 2 3 4 5 6 7 8 9 10 11 12 13 if((tree[i]-\u0026gt;getY()\u0026lt;player1-\u0026gt;getY()+70\u0026amp;\u0026amp;tree[i]-\u0026gt;getY()\u0026gt;player1-\u0026gt;getY()-45) ||(tree[i]-\u0026gt;getY()\u0026lt;player2-\u0026gt;getY()+70\u0026amp;\u0026amp;tree[i]-\u0026gt;getY()\u0026gt;player2-\u0026gt;getY()-45)){ tree[i]-\u0026gt;Raise(); if(tree[i]-\u0026gt;getY()\u0026lt;player1-\u0026gt;getY()-45){ player1-\u0026gt;Raise(); } if(tree[i]-\u0026gt;getY()\u0026lt;player2-\u0026gt;getY()-45){ player2-\u0026gt;Raise(); } } else{ tree[i]-\u0026gt;Lower(); } 树木和敌人随机位置生成 1 2 3 4 5 for(int i=1;i\u0026lt;TREE_NUM;i++){ //用QRandomGenerator库，随机生成-1400到1400之间的数字 tree[i]=new Object(QRandomGenerator::global()-\u0026gt;bounded(-1400,1400), QRandomGenerator::global()-\u0026gt;bounded(-1400,1400),1,this); } 僵尸追踪 僵尸首先会判断与两个玩家间的距离，追踪距离更近的玩家。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 void Enemy::chase(Player *p1, Player *p2) { int Xp1=p1-\u0026gt;getX(),Yp1=p1-\u0026gt;getY(),Xp2=p2-\u0026gt;getX(),Yp2=p2-\u0026gt;getY(); int disP1=(x-Xp1)*(x-Xp1)+(y-Yp1)*(y-Yp1); int disP2=(x-Xp2)*(x-Xp2)+(y-Yp2)*(y-Yp2); if(disP1\u0026lt;disP2){ if(x\u0026lt;Xp1){ x+=speed; enemy-\u0026gt;setPixmap(enemy_r); } else if(x\u0026gt;Xp1){ x-=speed; enemy-\u0026gt;setPixmap(enemy_l); } if(y\u0026lt;Yp1){ y+=speed; } else if(y\u0026gt;Yp1){ y-=speed; } } else{ if(x\u0026lt;Xp2){ x+=speed; enemy-\u0026gt;setPixmap(enemy_r); } else if(x\u0026gt;Xp2){ x-=speed; enemy-\u0026gt;setPixmap(enemy_l); } if(y\u0026lt;Yp2){ y+=speed; } else if(y\u0026gt;Yp2){ y-=speed; } } } 视频演示 源码 源码：https://github.com/kevinwu06/RectMans\n","date":"2023-05-12T00:00:00Z","image":"https://p.fiveth.cc/img/m/rectmans.jpg","permalink":"https://blog.fiveth.cc/p/1841/","title":"【Qt C++】TCP联机小游戏 RectMans"},{"content":"用Qt和C++开发了一个基于TCP协议的通信程序，源码放在文章底部了。\nTCP是一种传输协议，以服务器和客户端的形式运行。\nQt中提供了QTcpServer类来编写服务器端程序，以及QTcpSocket类来编写客户端程序。\n服务端开启对一个端口的监听，等待客户端连入。\n服务端 服务端继承于QTcpServer类，加上Q_OBJECT\n1 2 3 4 5 6 7 8 9 10 //头文件 class Server : public QTcpServer { Q_OBJECT } //源文件 Server::Server(QObject *parent) : QTcpServer{parent} { } 查询ip和端口 1 2 3 netstat -ano 活动连接列表 ipconfig /all 查看ip 监听 服务端用QTcpServer监听端口，用QTcpSocket 读取和写入\n1 server-\u0026gt;listen(QHostAddress::Any,8888); //开始监听端口 连入 连接后自动触发的函数，开始接受数据\n1 2 3 4 void Server::incomingConnection(qintptr handle){ socket.setSocketDescriptor(handle); connect(\u0026amp;socket,SIGNAL(readyRead()),this,SLOT(receiveData())); } 读取 1 2 3 4 5 void Server::receiveData() { QByteArray message=socket.readAll(); str=message.data(); //转为QString } 发送 1 2 3 4 void Server::sendData(QString text) { socket.write(text.toUtf8()); } 客户端 用QTcpSocket实现连接及收发\n1 2 3 4 5 6 7 8 9 10 QTcpSocket* socket; socket.connectToHost(IP,PORT); //连接 if(socket.waitForConnected(1000)){ //等待1秒连接 qDebug(\u0026#34;成功连接聊天室...\\n\u0026#34;); } else{ qDebug(\u0026#34;连接失败...\\n\u0026#34;); return; } connect(\u0026amp;socket,SIGNAL(readyRead()),this,SLOT(receiveData())); 接受和发送 接受和发送与服务端相同\n界面UI QSS是QT受CSS启发做的样式表语言，在简单的qt程序制作中非常好用。\n界面背景 在坐标(0,0)处放QLabel并拉满整个窗口，样式表中放入照片，照片要先导入到qrc资源文件中\n1 2 3 4 QLabel { border-image: url(:/Images/duckl.png); } 按钮样式表 hover是鼠标放在上面显示的样式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 QPushButton { border: 0.5px solid white; border-radius: 6px; background-color: rgb(90,194,198); min-width: 40px; font-family: \u0026#34;Microsoft YaHei\u0026#34;; font-size:11pt; font-weight: bold; color:white; } QPushButton:hover { border: 0.5px solid white; border-radius: 6px; background-color: #1fab89; min-width: 40px; font-family: \u0026#34;Microsoft YaHei\u0026#34;; font-size:10pt; font-weight: bold; color:white; } 全局样式表 编辑基类widget样式表\n1 2 3 4 5 6 7 8 9 10 11 12 13 QWidget{ border: none; } QLineEdit { border: 0.5px solid rgb(147, 150, 154); border-radius: 6px; background-color: rgba(40, 44, 52,150); min-width: 80px; font-family: \u0026#34;Microsoft YaHei\u0026#34;; font-size:11pt; font-weight: bold; color:rgb(147, 150, 154); } 程序源码 源码：https://github.com/kevinwu06/DuckChat\n","date":"2023-04-25T00:00:00Z","image":"https://p.fiveth.cc/img/m/duckchat.jpg","permalink":"https://blog.fiveth.cc/p/dcd3/","title":"【Qt C++】TCP聊天程序DuckChat"},{"content":"最近在学习Qt，做了个游戏当练手项目。\n断断续续大概写了两周，程序源码放在文章底部了。\n游戏美术 用软件Aseprite自己绘制。Aseprite是一款专门针对像素画的软件，界面简洁，适合快速上手，没有ps那些繁琐的功能。\n游戏动态背景用ps做成，因为ps的动画功能可以实现流畅的帧变换。\n游戏代码 接下来是如何用Qt提供的接口来实现一些游戏的基本功能\n动画 游戏人物的动态用的是gif动图\n用QLabel和QMovie实现\n1 2 3 4 5 6 7 QLabel *duck=new QLabel(this); QMovie *duck_stand=new QMovie(\u0026#34;Images/duck_stand.gif\u0026#34;); duck-\u0026gt;setMovie(duck_stand); duck_stand-\u0026gt;start(); //开始播放 duck-\u0026gt;setFixedSize(150,150); //设置大小 duck-\u0026gt;setScaledContents(true); //自动大小匹配 duck-\u0026gt;move(x,y); //移动位置 图片 显示静态图片用QLabel和QPixmap\n1 2 3 4 QLabel *duck=new QLabel(this); QPixmap duck_stand; duck_stand.load(\u0026#34;Images/duck_stand.gif\u0026#34;); QLabel-\u0026gt;setMovie(duck_stand); 事件处理 在head文件中加入，再在源文件中定义\n1 2 3 protected: void keyPressEvent(QKeyEvent* e); void keyReleaseEvent(QKeyEvent* e); 游戏主循环 控制帧率，一秒循环多少次\n1 2 3 QTimer *timer=new QTimer; connect(timer,\u0026amp;QTimer::timeout,this,\u0026amp;GameEngine::MainGame); //MainGame()是循环的函数 timer-\u0026gt;start(1000/FRAME); //FRAME帧率 Delay函数 Qt中要使用delay函数可以自己定义，代码如下。\n1 2 3 4 5 6 void delay(int msec) { QTime dieTime= QTime::currentTime().addMSecs(msec); while( QTime::currentTime() \u0026lt; dieTime ) QCoreApplication::processEvents(QEventLoop::AllEvents, 100); } 显示文字 1 2 3 4 5 QLabel *health=new QLabel(widget); string_health_number= QString::number(health_number, 10); //将int类型转化成QString health-\u0026gt;setText(string_health_number); health-\u0026gt;setFont(QFont(\u0026#34;Microsoft YaHei\u0026#34;, 20, QFont::Bold)); health-\u0026gt;setStyleSheet(\u0026#34;color:red;\u0026#34;); 源码 源码：https://github.com/kevinwu06/FighterDuck\n","date":"2023-04-15T00:00:00Z","image":"https://p.fiveth.cc/img/m/fighterduck.jpg","permalink":"https://blog.fiveth.cc/p/f1e0/","title":"【Qt C++】Fighter Duck"},{"content":"简介 《深入浅出程序设计竞赛》是洛谷站长出的书，帮助青少年上手C++算法竞赛。书中对学习算法竞赛的顺序编排非常好，很系统，很适合用于算法竞赛入门。文章最后有书籍pdf版。\n下面是我从基础语言入门部分(第一部分)总结出来的精华笔记。\n文件操作 在文件里创建 title.in文件\n1 2 3 freeopen(\u0026#34;title.in\u0026#34;,\u0026#34;w\u0026#34;,stdin); freeopen(\u0026#34;title.out\u0026#34;,\u0026#34;r\u0026#34;,stdout); 头文件 cstdio头文件 1 2 3 4 //输入 scanf(\u0026#34;%d\u0026#34;,\u0026amp;a) //输出 printf(%d,a); cmath头文件: 包含一系列数学函数\n1 根号sqrt, 几次方pow algorithm头文件： 一系列算法函数\n1 min, max, sort, swap cstring头文件： 用于char字符串\n1 2 strlen获取字符串长度，strcpy复制字符串内容 fgets读入字符串，sscanf获取字符串，sprintf输 杂货 ASCII码: \u0026lsquo;A\u0026rsquo;=66, \u0026lsquo;a\u0026rsquo;=97\n强制转换: 1 (int)a 函数: 1 2 3 4 5 6 7 stat(int a) //在这个函数里面对放入的a进行修改，函数外是不会生效的。 stat(int \u0026amp;a) //相当于给放入的变量取了个别名，对其修改，该变量也会改变。 stat(int a[]) //相当于传入\u0026amp;a[] scanf(\u0026#34;%d\u0026#34;,\u0026amp;n) //这也是一样，相当于把n的地址告诉函数，这样才能输入到n中。 左移/右移运算符 1 2 3 4 //左移运算符 i\u0026lt;\u0026lt;n = i*2^n^ //右移运算符 i\u0026gt;\u0026gt;n=i/2^n^ 随机数 1 2 3 4 5 #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;ctime\u0026gt; srand(time(0)) ans=rand()%a\t//生成0到(a-1)随机数 //ans=rand()%(b-a+1)+a\t生成a到b随机数 异或运算符: ^ 一个成立一个不成立\n1 2 true^false=true true^true=false 字符串 char字符串 结束标记字符：\u0026rsquo;\\0\u0026rsquo;\n读入字符串方法：\n1 scanf(\u0026#34;%s\u0026#34;,s); 1 cin\u0026gt;\u0026gt;s; 这两种方法只能读到空格或者换行就会终止\n如果要输入包括空格或换行的字符串，并存入一个字符串中，就用下面这种方法\n1 2 3 4 5 6 while (1) { s = getchar();//读入字符 if (s == EOF) break; //... putchar(s); } 结束输入的时候，要使用组合键Ctrl+Z，然后回车。\n这是因为getchar返回EOF(End of file)代表文件读入完毕。\nwindows下输入Ctrl+z / Linux下输入Ctrl+D 来输入EOF标记\nstring字符串 加强版字符串，可以赋值、拼接\n字符串string需要使用头文件 string,包括下面的常用方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 //定义字符串变量s string s; //拼接字符串1 s+=str; //拼接字符串2 s.append(str); //比较字符串 s 的字典序是否在字符 str 的字典序之前 s\u0026lt;str; //获取长度1 s.size(); //获取长度2 s.length( ); //截取字符串s,从第 pos 个位置开始len 个字符 s.substr(pos,len); //在字符串s的第 pos 个字符之前插字符串 st s.insert(pos,str); //在字符串 s 中从第 pos 个字符开始寻找 str,并返回位置,如果找不到返回-1。pos 可以省略,默认值是 0。 s.find(str,[pos]); //可以获取带空格字符串 getline(cin,s); 深入浅出程序设计竞赛.zip 蓝奏云\n","date":"2023-03-31T00:00:00Z","image":"https://p.fiveth.cc/img/m/shenji.jpg","permalink":"https://blog.fiveth.cc/p/98d7/","title":"阿谦读书笔记：《深入浅出程序设计竞赛》"},{"content":"各种排序 排序 概述 时间复杂度 计数排序 对应票投入对应票箱 O(n) 选择排序 最小的放前 (两重循环) O(n^2^) 冒泡排序 依次比较相邻 (两重循环) O(n^2^) 插入排序 依次拿出一张牌插入排列中 (两重循环) O(n^2^) \u0026hellip; 这些排序各适用不同情况，但时间复杂度总体较大。\n快速排序 程序设计竞赛中最普遍的排序。\n随机选择哨兵，时间复杂度O(n log n)。但极端情况O(n^2^)。\n概述：\n选出一个哨兵，比哨兵小的数全放左边，比他大的全放右边。\n再分别在左边和右边选出哨兵，进行分类。\n以此循环，直到排序完成。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;iostream\u0026gt; using namespace std; void qsort(int num[],int first,int last) { int i = first, j = last, flag = num[(first + last) / 2], temp; do { while (num[i] \u0026lt; flag) i++; while (num[j] \u0026gt; flag) j--; if (i \u0026lt;= j) { temp = num[i]; num[i] = num[j]; num[j] = temp; i++; j--; } } while (i \u0026lt;= j); //带=为了让i和j交错而过，这样才可以用递归 if(first\u0026lt;j) qsort(num, first, j); if(i\u0026lt;last) qsort(num, i, last); } int main() { int n, num[100000]; cin \u0026gt;\u0026gt; n; //必须从i=1开始 for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; num[i]; } qsort(num,1,n); for (int i = 1; i \u0026lt;= n; i++) { cout \u0026lt;\u0026lt; num[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } return 0; } 当然也可以直接用algorithm头文件中的sort函数，\n我们学会自己写是为了理解原理，提升思维，\n同时在有特殊需求的时候可以更自定义化。\n","date":"2023-02-28T00:00:00Z","image":"https://p.fiveth.cc/img/m/sort.webp","permalink":"https://blog.fiveth.cc/p/92b9/","title":"阿谦教算法：如何学精排序算法？"},{"content":"Introduction This is a book on the Computer Science book list of Oxford. It is a good book for crossing the threshold of computer science.\nThe book briefly introduces the some fundamental knowledges of computer science through an interesting adventure story.\nI recognized many computational terms in the book that I\u0026rsquo;ve already learned in Chinese. So it helped me to know the spelling of the computational terms in English. And I also learned a lot that I\u0026rsquo;ve not learned about. I\u0026rsquo;ll keep on studying computer science and be on the way for fulfilling my dream.\nI note down all the essential terms in the book to sum it up and help me for review.\nBase Computer Science: a way of thinking about problems.\nA set of core concepts-approaches to solving fundamental problems,and how combine them to solve larger and more complex problem.\n**Algorithm: **a set of specific steps for solving a problem.\n**Variable: **a place in memory where you can store a single piece of data.\nIF-ELSE statements: branch off and execute one of different blocks of code.\n**Loops: **programming constructs for repeating a set of instructions until some terminal criterion is met.\n**Boolean logic: **base on two values: TRUE and FALSE\nBinary: a number system which each digit can take one of 0 or 1.\n101=(1x2^2^)(0x2^1^)(1x2^0^)\n**Pseudocode: **an informal understandable way of writing algorithms.\nData Structure Arrays: like a set of bins with a fixed number of slots.\nStrings: sequences(array) of characters\nSwapping two values:\n1.put one into temporary storage\n2.the other in the memory location of first entry\n3.the data from temporary storage is written to second entry.\nPointers: variables that hold addresses in the computer memory. Flexible\nLinked lists: data structures that store lists of items. Use pointer to store the next and previous node.\nStacks: last-in, first-out data structure.\nQueues: first in, first out data structure.\nPriority queues: return the highest priority data.\nBinary search trees: efficient searches by value like a tree.\nCaching data: storing a copy of data in a quickly accessible location to speed up future accesses of that data.\nRecursion: a problem-solving technique that builds a solution to a problem from solutions to smaller subproblems of the same type.\nBinary search: algorithm for efficiently finding a target value within a sorted list.\nInsertion sort: simple inefficient sorting an array of number.\nBubble sort: Swapping adjacent elements if they are out of order.\nMerge sort: Break the data in half, sort each half separately using merge sort and merge together.\n*Oracle\u0026rsquo;s Array: Using algorithms and data structures together to create complex programs.\nGraph: is defined by a set of nodes and a set of edges that link together the nodes.\nDirected/Undirected\nWeighted/Unweighted\nDijkstra\u0026rsquo;s algorithm: find the shortest path from a given starting node to all other nodes in the graph.\nRepresentations of graphs: two common data structure representing graphs:\n​\tadjacency matrix: One row and one column for each node.\n​\tadjacency list: a separate list of neighbors for each node.\nTraveling salesman problem: find the shortest path through a graph that visits each node and return to the starting node. NP-hard\nDepth-first search: a search algorithm that fully explores a single path before backtracking to test other paths.\nMinimum Spanning Tree: the smallest set of edges that all of the nodes are connected.\nHamiltonian path: visits each node in a graph exactly one time. NP-Hard\nComputational Thinking Complex algorithms build on a core set of fundamental concepts. Mastering them and learn to combine them is the key to solving to problems.\nNP-Hard: computational problems for which there are no known efficient and exact solution.\nQuicksort: a recursive sorting algorithm that is similar to merge sort but faster.\nComments: additional text within code that improve the read ability.\n","date":"2023-02-27T00:00:00Z","image":"https://p.fiveth.cc/img/m/computa.jpg","permalink":"https://blog.fiveth.cc/p/ee7c/","title":"阿谦读书笔记：Computational Fairy Tales"},{"content":"SDL（Simple DirectMedia Layer）是一套开放源代码的跨平台多媒体开发库，使用C语言写成。SDL提供了数种控制图像、声音、输出入的函数，让开发者只要用相同或是相似的代码就可以开发出跨多个平台的应用软件。现SDL多用于开发游戏、模拟器、媒体播放器等多媒体应用领域。\n最近前段时间浅学习了下SDL，以及做游戏。这篇文章总结下。\n游戏结构 做游戏这里最主要的是面向对象编程思想。\n多创建类文件可以帮助我们更好的理清逻辑，管理代码。\n整个游戏的结构：\n1 2 3 4 5 6 7 8 Init();//初始化 while(Running)//运行状态循环 { Events();//事件 Loop();//循环 Render();//渲染 } Clean();//清除 这样把整个游戏结构写成函数形式可以让我们更好的管理代码。这应该就是我们main函数大概的样子。\nSDL函数 接下来我们来看看SDL给我们提供的函数，让我们怎么去实现游戏功能。\n首先我们来看看一个简单的SDL创建窗口的程序。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 int main(int,char**) { if (SDL_Init(SDL_INIT_VIDEO)) { SDL_Log(\u0026#34;Cannot Init Video,%s\u0026#34;, SDL_GetError()); return 1; } SDL_Window* win = SDL_CreateWindow( \u0026#34;Title\u0026#34;, SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, 400, 300, SDL_WINDOW_SHOWN ); if (win == NULL) { SDL_Log(\u0026#34;Cannot Create Window,%s\u0026#34;,SDL_GetError()); return 1; } SDL_Delay(3000); //延迟3000毫秒 SDL_DestroyWindow(win); SDL_Quit(); return 0; } 检测故障 我们可以看到我们在初始化和创建的时候会写一个判断语句。\n这是为什么？\n因为有时可能会因为各种原因导致初始化失败或者创建失败，到后面代码多了如果某个环节失败了，我们想要找出问题所在会非常困难。\n所以我们在初始化和创建的时候写判断语句，比如第一个SDL_Init()，这个SDL给出的函数如果失败了会返回1(可以右键进入定义代码查看)，所以如果返回了1，我们就用**SDL_Log()函数(SDL给出的输出函数,也可以用cout或者printf)输出问题，后面的SDL_Error()**可以获取问题。\n这样的检测故障的判断是必须的。\n清除 可以看到我们最后使用了\nSDL_DestroyWindow(win); SDL_Quit(); 这是官方给出的销毁/清除的函数。\n在我们初始化了SDL的功能后，在程序末尾我们必须用SDL_Quit()将其清除。\n同样道理，我们用SDL创建的数据变量也应该销毁/释放掉。\n(每个数据变量都有对应的销毁/释放函数，如SDL_DestroyRenderer,SDL_FreeSurface)\nSDL学习 SDL给出了非常非常多的功能函数。\n大家使用时应该学会查看官方文档，里面都给出了详细的使用方法。\n这是我之前学习SDL的文件，里面有一些最基本功能的实现，大家可以看看。\nSDL学习文件 蓝奏云\n","date":"2023-01-25T00:00:00Z","image":"https://p.fiveth.cc/img/m/sdl.jpg","permalink":"https://blog.fiveth.cc/p/b01b/","title":"如何用SDL开发游戏？"},{"content":"我们存储很多数的时候，通常使用数组，但是数组不够灵活。\n哦？为什么说不灵活？\n我们如果要在一个数组前面或者中间插入一个数，就会很麻烦。\n假设我们有一个数组a,里面是排序好的数字,我们要将7按大小顺序插入数组\n我们就得把后面的数全都依次往后移一位，再将7放入。\n这样如果后面的数非常多的话就会很耽误时间。\n所以我们需要用到链表。\n链表就是利用结构体和指针，在存储数据的同时，存储一个指向下一个结点的指针。\n这样我们要插入数字的时候，只要修改下指针的指向，就可以快速的进行插入或取出之类的操作。\n链表有很多种：\n**单链表:**每个结点记录后继(图片演示的就是)\n**双链表:**每个结点记录前驱和后继，它比单链多了个往前走的功能\n**循环单链表:**将单链表的最后一个结点的后继指向第一个结点，形成一个环形结构\n**循环双链表:**将双链表连成环形\n\u0026hellip;（还有几种就不一一列述了）\n这里我们设计一个程序实现一下链表，首先输入四个按大小顺序排列的数字，然后再输入要插入的数字，\n程序会输出插入后的排列\n先上代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 #include \u0026lt;iostream\u0026gt; using namespace std; struct node { int data;//存数据 node* next;//后继指针 }; int main() { int a; node* head, * p, * q = NULL; head = NULL; for (int i = 1; i \u0026lt; 5; i++) { //用指针p指向一个动态申请的node大小的空间 p = (node*)malloc(sizeof(node)); cin \u0026gt;\u0026gt; a; //将数据存入当前结点(p指向的结点) p-\u0026gt;data = a; p-\u0026gt;next = NULL; if (head == NULL)head = p;//如果是第一个结点，就将头指针指向当前结点 else q-\u0026gt;next = p;//否则将上一个结点的后继指针指向当前结点 q = p;//将q指向当前结点 } //插入数据 int b; cin \u0026gt;\u0026gt; b; node* t = head;//从链表头开始遍历 while (t != NULL) { if (t-\u0026gt;next-\u0026gt;data \u0026gt; b) { p = (node*)malloc(sizeof(node)); //将数据存入当前结点(p指向的结点) p-\u0026gt;data = b; p-\u0026gt;next = t-\u0026gt;next;//将当前结点的后继指针指向下一结点 t-\u0026gt;next = p;//将上一结点的后继指针指向当前结点 break; } t = t-\u0026gt;next;//下一结点 } //输出 t = head;//从链表头开始遍历 while (t != NULL) { cout \u0026lt;\u0026lt; t-\u0026gt;data \u0026lt;\u0026lt; endl; t = t-\u0026gt;next;//下一结点 } //释放动态申请的空间(确保安全) t = head; while (t != NULL) { node* current = t;//记录当前结点 t = t-\u0026gt;next;//下一结点 free(current); } return 0; } 代码不长，但是可能需要时间理解。\n讲讲malloc函数，malloc函数的作用是动态分配内存。\n每次输入数据前，我们就用p指向一个动态申请的新空间，然后存入数据。\n程序的最后，我们用free()函数来释放动态申请的空间，这样可以让我们的程序更安全。\n我们学习c语言和c++应该追求最大程度地优化，排除可能出现的问题。\n","date":"2023-01-09T00:00:00Z","image":"https://p.fiveth.cc/img/m/linklist.webp","permalink":"https://blog.fiveth.cc/p/c8a8/","title":"阿谦教算法：如何学精链表？"},{"content":"如何高效筛素数？让我们来看看\n**题目：**生成一个1到n范围内的质数数组\n菜鸟这样做（枚举法） 从1枚举到n，判断是素数就存入数组\n下面是判断方法\n菜鸟： 从2枚举到n-1，如果有能整除该数的，该数就是质数。\n进化版菜鸟： 菜鸟进化了，从2枚举到$\\sqrt n$\n高手版 埃氏筛 这样筛掉后每次下一位没被筛掉的数就都是质数\n1 2 3 4 5 6 7 8 9 10 11 12 bool numlist[100000]; //0代表质数，1代表非质数 int prime[100000], count; void work(int n){ for(int i=2; i\u0026lt;=n; i++){ if(numlist[i]==0){ //如果是质数 prime[++count] = i ; //就先存入 for(int j=i; i*j\u0026lt;=n; j++) numlist[i*j] = 1; //然后将其平方后的所有倍数筛掉 } } return; } 但是这钟筛法还不是最优，因为p的倍数会重复，所以有些数会被重复筛掉。\n那么就引出了我们的最终筛法。\n欧拉筛 这个筛法避免了重复筛，思路就是：每个合数只会被其最大非自身因数筛除\n多说无益，先上代码：\n1 2 3 4 5 6 7 8 9 10 11 bool numlist[100000]; //0代表质数，1代表非质数 int prime[100000], count; void work(int n){ for (int i = 2; i \u0026lt;= n; i++) { if (numlist[i]==0) ans[++count] = i;//是质数就先存入数组 for (int j = 1; j \u0026lt;= count \u0026amp;\u0026amp; i*prime[j] \u0026lt;= n; j++) { numlist[prime[j] * i] = 1; //每次让i乘已放入的质数，然后标记非质数 if (i % prime[j] == 0) break;//但是如果i可以被该数整除就停止（关键） } } 现在我们再来分析下。\n从表可以看出，我们会筛掉每个质数p的平方之后的p的倍数，但是如果i是p的倍数，那就说明它们的乘积那个合数的最大非自身因数不是i，所以不筛。\ni 的值 质数表 筛去的数 2 2 4 3 2, 3 6, 9 4 2, 3 8 5 2, 3, 5 10, 15, 25 6 2, 3, 5 12 7 2, 3, 5, 7 14, 21, 28, 35 ⋯ ⋯ ⋯ ","date":"2022-12-23T11:29:22Z","image":"https://p.fiveth.cc/img/m/oula.webp","permalink":"https://blog.fiveth.cc/p/a680/","title":"算法：如何高效地筛出质数？(欧拉筛)"},{"content":"这是我之前学习html做的一点笔记，是一些基础，非常简单好学。\n·网页基本信息 doctype声明\nmeta描述性标签 ·网页基本标签 标题标签 h1~h6\n段落标签 p\n换行标签 br\n粗体斜体 粗体b 斜体i\n特殊符号 （\u0026amp; ;）\n空格 nbsp\n大于gt 小于lt\n版权copy\n·图像标签 ·超链接标签 页面跳转 锚链接 锚标记 a id=“top”\n邮件链接 mailto:\nQQ链接 上“qq推广”官网\n·*概念:行内元素和块元素 块元素 独占一行的元素\n行内元素 撑开宽度的元素\n·列表 有序列表、无序列表 自定义列表 ·表格标签 ·媒体元素 ·页面结构 ·iframe内联框架 链接控制iframe窗口跳转\n·表单 表单 元素表单格式 文本框 text\n单选框 radio\n多选框 checkbox\n按钮 button\n下拉框 文本域、文件域 滑块、搜索框 简单验证 表单应用 只读 readonly\n禁用 disabled\n隐藏 hidden\n表单初级验证 placeholder 提示信息\nrequired 必填\npattern 正则表达式（百度上搜索各种）\n图片来源于b站狂神说的html课程，推荐。\n","date":"2022-12-21T00:00:00Z","image":"https://p.fiveth.cc/img/m/html.jpg","permalink":"https://blog.fiveth.cc/p/c57/","title":"阿谦学习笔记：HTML"},{"content":"我们知道每种数据类型的储存空间是有限的，如果我们要储存非常大的数可以用long long，更大则unsigned long long，再大就是有些编译器提供的_int128类型，但是要是比这还要大呢?我们就需要用到高精度运算，用数组来模拟非常大的整数。\n我们只要定义一个数组，把数字分别放入数组序列中就可以储存非常大的数。\n接下来我们看看怎么使用高精度运算。\n（注意以下都是我个人的解法，不一定是最优解，借鉴学习即可）\nA+B **题目：**高精度加法，相当于 a+b problem，不用考虑负数。（洛谷P1601题）\n输入a和b，然后输出a+b，太简单了！但是，题目要求的是高精度加法，也就是说输入的a和b是非常大的，我们要使用高精度才能储存该数进行处理。\n首先我们看看加法的竖式\n如果超过10就要向下一位进位，进位的数字和下一位的值相加\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include\u0026lt;iostream\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;algorithm\u0026gt;//包含max函数 using namespace std; int A[500], B[500], C[500];//这个定义必须放在主函数外!!!这样它才会初始化，我被这个坑惨了 int main(){ string a,b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; int lena = a.length(), lenb = b.length(); int len = max(lena, lenb); //把字符变成对应的数字，并倒序存入 for (int i = 0; i \u0026lt; lena; i++) A[i] = a[lena-1-i] - \u0026#39;0\u0026#39;; for (int i = 0; i \u0026lt; lenb; i++) B[i] = b[lenb-1-i] - \u0026#39;0\u0026#39;; //相加并处理进位 for (int i = 0; i \u0026lt; len; i++) { //相加 C[i] += A[i] + B[i]; //进位 C[i + 1] = C[i] / 10; C[i] = C[i] % 10; } //如果进位使得位数增加，我们就多输出一位 if (C[len]) len++; //因为我们之前是倒序存入，所以现在倒序输出就又正了 for (int i = len-1 ; i \u0026gt;= 0; i--) cout \u0026lt;\u0026lt; C[i]; return 0; } A*B **题目：**给出两个非负整数，求它们的乘积。每个非负整数不超过 10^2000^（洛谷P1303题）\n还是一样，看似是道弱智题，但是我们要注意输入值的范围，数值非常大，再加上要相乘，很容易就会超过我们数据类型范围，所以又要用到我们的高精度方法。\n算乘法，我们就先复习下乘法竖式\n几个需要知道的点\n和加法非常像，也是超10进位。 这里有个很重要的规律，我们倒着数，第一个数的i位乘第二个数的j位，它们的乘积会到第(i+j-1)位上。 乘积的位数不超过两数的位数之和。 知道了这个，我们就可以开始了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include\u0026lt;iostream\u0026gt; #include\u0026lt;string\u0026gt; using namespace std; int A[5000], B[5000], C[5000]; int main(){ string a, b; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; int lena = a.length(), lenb = b.length(); //转化成对应数字并倒序存入 for (int i = 1; i \u0026lt;= lena; i++) A[i] = a[lena - i]-\u0026#39;0\u0026#39;; for (int i = 1; i \u0026lt;= lenb; i++) B[i] = b[lenb - i]-\u0026#39;0\u0026#39;; //计算乘积 for (int i = 1; i \u0026lt;= lena; i++) { for (int j = 1; j \u0026lt;= lenb; j++) C[i + j - 1] += A[i] * B[j]; } int len = lena + lenb;//乘积的位数不超过两数的位数之和 //处理进位 for (int i = 1; i \u0026lt;= len; i++) { C[i + 1] += C[i] / 10; C[i] %= 10; } //去掉多余输出的位数 while (!C[len]) len--; //特殊情况，乘积等于0 if (len \u0026lt; 1) len = 1; //输出 for (int i = len ; i \u0026gt;= 1; i--) cout \u0026lt;\u0026lt; C[i]; return 0; } 阶乘之和 题目描述\n用高精度计算出 $S = 1! + 2! + 3! + \\cdots + n!$（$n \\le 50$）。\n其中 ! 表示阶乘，定义为 $n!=n\\times (n-1)\\times (n-2)\\times \\cdots \\times 1$。例如，$5! = 5 \\times 4 \\times 3 \\times 2 \\times 1=120$。\n输入n，输出s。（洛谷P1009题）\n这道题可以说是前两道题的结合。\n这是我的解法，因为这道题较特殊，所以可以做到比前两道的代码还短，可能有点抽象，要仔细思考\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include\u0026lt;iostream\u0026gt; using namespace std; int main() { int i, A[1005] = { 0 }, B[1005] = { 0 }, n, j; cin \u0026gt;\u0026gt; n; A[0] = B[0] = 1; //这个循环是外面的加法 for (i = 2; i \u0026lt;= n; i++) { //阶乘的相乘 for (j = 0; j \u0026lt; 100; j++) B[j] *= i; //阶乘的进位 for (j = 0; j \u0026lt; 100; j++) if (B[j] \u0026gt; 9) { B[j + 1] += B[j] / 10; B[j] %= 10; } //每算完一个阶乘就加进结果并处理进位 for (j = 0; j \u0026lt; 100; j++) { A[j] += B[j]; if (A[j] \u0026gt; 9) { A[j + 1] += A[j] / 10; A[j] %= 10; } } } //去除多余的位数 for (i = 100; i \u0026gt;= 0 \u0026amp;\u0026amp; A[i] == 0; i--); //输出 for (j = i; j \u0026gt;= 0; j--) cout\u0026lt;\u0026lt; A[j]; return 0; } 灵活掌握，举一反三才能在程序竞赛中绽放自我。\n","date":"2022-12-20T00:00:00Z","image":"https://p.fiveth.cc/img/m/calculator.webp","permalink":"https://blog.fiveth.cc/p/e08/","title":"算法：高精度运算"},{"content":"辗转相除法是一种求最大公因数的计算方法。\n这种方法在编程中很常用，在数学计算中也可以用来求很复杂的最大公因数问题。\n如何使用 题目：求最大公因数(36,14)\n我们如何用辗转相除法做这道题呢？ $$ \\displaylines{ 反复用除数除以余数直到除尽\\ 36{\\div}14=2\\dots8\\ 14{\\div}8=1\\dots6\\ 8{\\div}6=1\\dots2\\ 6{\\div}2=3\\ 最后一个除数就是最大公约数，也就是2 } $$ 我们算出最大公约数(36,14)=2\n到这里，我们就知道如何使用辗转相除法了。\n但是，鲁迅曾说过“我们学公式必须得懂得原理”，我们明白了原理才能灵活运用\n原理 求最大公因数(a,b)\n首先我们推出这几条式子 $$ \\displaylines{ a{\\div}b=q\\dots r \\ a=bq+r \\ r=a-bq } $$ 这是我们辗转法的原理 $$ \\displaylines{ (a,b)=(b,r) \\a和b的最大公约数就等于b和r的最大公约数 } $$ 接下来让我们证明这条公式 $$ \\displaylines{ (1)设(a,b)=d\\ 那么a=dm,b=dn\\ 然后我们将其带入r=a-bq\\ 得r=d(m-nq)\\ 因为m,n,q都是整数，所以r是d的倍数，d是r的因数\\ 所以：只要是a,b的因数，就一定是d,r的约数\\ } $$\n$$ \\displaylines{ (2)设(b,r)=d\\ 和之前一样，那么b=dx,r=dy\\ 然后将其代入a=bq+r\\ 得a=d(xq+y)\\ 因为x,q,y都是整数，所以a是d的倍数，d是a的因数\\ 所以：只要是d,r的因数，就一定是a的因数\\ } $$\n这样，我们就得出(a,b)的因数和(b,r)的因数相同，它们的因数都相同，那么它们的最大公因数也就相同。\n所以我们要求(a,b)的最大公因数，我们就通过可以求(b,r)的最大公因数来得到。\n现在我们再来看看开头的题\n题目：求最大公因数(36,14)\n反复用(a,b)=(b,r)的方法\n(36,14)=(14,8)=(8,6)=(6,2)\n最后得到(6,2)，显而易见最大公约数是2\n写gcd函数 接下来看看我们如何在C++中用辗转相除法写gcd函数\ngcd函数就是用来求最大公因数的函数\n1 2 3 4 5 6 7 int gcd(int a,int b) { while (a % b != 0) //a能被b整除时就终止循环 { int r = a % b; a = b; b = r; //讲a换成除数b，b换成余数r } 当然也可以直接用algorithm头文件中的gcd函数，\n我们学会自己写是为了理解原理，提升思维，\n自己写还可以在有特殊需求的时候更自定义化。\n","date":"2022-12-14T00:00:00Z","image":"https://p.fiveth.cc/img/m/gcd.webp","permalink":"https://blog.fiveth.cc/p/72c/","title":"阿谦教算法：如何求最大公因数？(辗转相除法)"},{"content":"{% tip info %}2024.4 我出了视频版教程啦：bilibili视频链接{% endtip %}\n我的个人博客搭建成功啦！\n这篇文章会给大家分享我是如何从0开始搭建我的个人独立博客的\n接下来我们开始吧\n文章比较精简，没有废话，不要跳步\n准备工具 首先我们需要到对应网站下载需要的工具\n下载nodejs\n(这篇文章里有修改nodejs缓存路径的教学:文章链接，c盘战士可以不看)\n下载git\n一直点确定就行，全部按它默认勾的\n(这里有一篇详细安装教程文章链接，可以不看)\n接下来我们测试下是否都下载成功\n管理员运行cmd，依次输入\n1 2 3 node -v npm -v（这个是node附带的） git -v 下载hexo\n1 npm install hexo-cli -g 搭建仓库 成功下载好工具之后，我们开始搭建GitHub存储静态页面的仓库\n首先注册/登入Github\n点击Create a new repository进入新建仓库页面\n仓库名输入：\n1 用户名.github.io 勾选 Public\n勾选 Add a README file\n拉到下面点击create创建\n生成SSH Keys 进入任意文件夹，右键空白处然后点Git bash here,输入\n1 ssh-keygen -t rsa -C \u0026#34;邮件地址\u0026#34; 然后敲4次Enter⌨️\n然后进入C:\\Users\\用户名，在里面进入.ssh文件\n用记事本打开里面的id_rsa.pub,全选复制里面的代码\n然后打开github\n进入用户设置，找到SSH keys\n新建SSH keys，名称随意，在下面粘贴代码，\n然后创建\n测试是否成功\n在git bash中输入\n1 ssh -T git@github.com 回车，然后再输入yes\n本地生成博客内容 在喜欢位置新建文件Blog，然后进入文件夹\n右键空白处然后点Git bash here，输入\n1 hexo init 如果‘command not find’，就在前面加上npx，如：npx hexo init\n然后\n1 hexo install 接下来依次输入\n1 2 hexo g hexo s （如果不成功的话就重复直到成功，因为国内与github连接不稳定）\n现在就可以复制生成的链接进入浏览器看到我们生成的本地服务器了\n然后回到命令行，ctrl+c关闭\n上线博客 进入之前的Blog文件夹，用记事本打开_config.yml\n拉到最下面将deploy后面的全删掉，复制粘贴这段\n1 2 3 type: git repository: branch: main 注意缩进格式：每行前面都有两个空格不要删，每个冒号后面都有个空格也不要删！\n去github之前生成的仓库页面，点code，复制https链接\n将其粘贴到我们记事本中的repository：后面\n然后保存退出\n回到博客文件夹，git bash\n安装自动部署发布工具\n1 npm install hexo-deployer-git --save 然后在Blog文件夹右键打开git bash，依次输入\n1 2 hexo g（生成） hexo d（上传） 如果是第一次使用git的话会需要配置\n1 2 git config --global user.email \u0026#34;你的邮箱\u0026#34; git config --global user.name \u0026#34;你的名字\u0026#34; 配置完后再hexo d上传\n在跳出来的窗口内进行登录\n接下来我们就成功把本地内容上传到github了\n上传成功以后，我们就算搭建好了！上自己的网址看看吧\n网址是我们之前设的仓库名：用户名.github.io\n网站资料 我们的博客标题还是默认的hexo，整个页面是初始默认的，接下来我们对其进行修改\n用记事本打开我们blog文件夹中的_config.yml文件\n将#Site下面按自己的需求填上\n1 2 3 4 5 6 7 8 ## Site title: 标题 subtitle: 副标题 description: 描述 keywords: 关键词 author: 站主 language: 语言（可以填写zh-CN） timezone: 时区（可以填写Asia/Shanghai） 然后保存\n如何上传文章 我们在Blog文件夹中打开git bash,输入下方代码就可以生成新的文章md文件\n1 hexo new 文章标题 文章是.md格式，在我们的Blog文件夹中的source/_posts中\n推荐用Typora软件来编辑.md格式的文件\nTypora官网：https://www.typoraio.cn/（89元终身使用，推荐正版）\n破解版奉上：蓝奏云文件\n然后我们用Typora软件打开该.md文件就可以开始写文章了\n写好以后，我们还是一样打开git bash生成、上传\n1 2 hexo g hexo d 至此，我们就成功搭建好基本的博客了，剩下的就是对博客的一些优化和美化了。\n我目前使用的hexo博客主题是anzhiyu，推荐主题：Butterfly，anzhiyu\n大家可以参阅主题文档进行安装配置\n有什么问题的话欢迎评论。\n{% tip info %}\n本篇下文：Hexo搭建进阶：Vercel部署、主题安装、基础用法\n我的Hexo优化系列：Hexo文章目录\n{% endtip %}\n","date":"2022-12-10T00:00:00Z","image":"https://p.fiveth.cc/img/m/hexo.jpg","permalink":"https://blog.fiveth.cc/p/bb32/","title":"如何用Hexo搭建个人博客?"}]